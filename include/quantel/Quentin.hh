// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __Quentin_hh__
#define __Quentin_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_Quentin
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_Quentin
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_Quentin
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE Quentin

_CORBA_MODULE_BEG

#ifndef __Quentin_mDirectoryViewer__
#define __Quentin_mDirectoryViewer__

  class DirectoryViewer;
  class _objref_DirectoryViewer;
  class _impl_DirectoryViewer;
  
  typedef _objref_DirectoryViewer* DirectoryViewer_ptr;
  typedef DirectoryViewer_ptr DirectoryViewerRef;

  class DirectoryViewer_Helper {
  public:
    typedef DirectoryViewer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DirectoryViewer, DirectoryViewer_Helper> DirectoryViewer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DirectoryViewer,DirectoryViewer_Helper > DirectoryViewer_out;

#endif

#ifndef __Quentin_mServer__
#define __Quentin_mServer__

  class Server;
  class _objref_Server;
  class _impl_Server;
  
  typedef _objref_Server* Server_ptr;
  typedef Server_ptr ServerRef;

  class Server_Helper {
  public:
    typedef Server_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Server, Server_Helper> Server_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Server,Server_Helper > Server_out;

#endif

#ifndef __Quentin_mZonePortal__
#define __Quentin_mZonePortal__

  class ZonePortal;
  class _objref_ZonePortal;
  class _impl_ZonePortal;
  
  typedef _objref_ZonePortal* ZonePortal_ptr;
  typedef ZonePortal_ptr ZonePortalRef;

  class ZonePortal_Helper {
  public:
    typedef ZonePortal_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ZonePortal, ZonePortal_Helper> ZonePortal_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ZonePortal,ZonePortal_Helper > ZonePortal_out;

#endif

  _CORBA_MODULE_VARINT const ::CORBA::Long maxNumber _init_in_decl_( = 9999 );

  _CORBA_MODULE_VARINT const ::CORBA::Long noNumber _init_in_decl_( = -1 );

  enum ConflictMode { findNumber, renumber, denumber, fail /*, __max_ConflictMode=0xffffffff */ };
  typedef ConflictMode& ConflictMode_out;

  enum FindMode { findExact, findForwards, findBackwards /*, __max_FindMode=0xffffffff */ };
  typedef FindMode& FindMode_out;

  _CORBA_MODULE_VARINT const ::CORBA::Long noTicket _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Long defaultAspect _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Long aspect16x9 _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Long aspect4x3 _init_in_decl_( = 2 );

  _CORBA_MODULE_VARINT const ::CORBA::Long defaultPlayMode _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Long box _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Long cut _init_in_decl_( = 2 );

  _CORBA_MODULE_VARINT const ::CORBA::Long anamorphic _init_in_decl_( = 3 );

  _CORBA_MODULE_VARINT const ::CORBA::Long play14x9 _init_in_decl_( = 4 );

  _CORBA_MODULE_VARINT const ::CORBA::Long frameVideo _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Long playModeOverride _init_in_decl_( = 8 );

  _CORBA_MODULE_VARINT const ::CORBA::Long playModeShift _init_in_decl_( = 4 );

  _CORBA_MODULE_VARINT const ::CORBA::Long aspectShift _init_in_decl_( = 12 );

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagOriginator;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagRecordServer;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagRecordChannel;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagRecordTime;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagSceneChange;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagPixelAspect;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagCropRectangle;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagMatch;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagValidVideo;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagFreezeMode;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagRecordRate;

  _CORBA_MODULE_VAR _core_attr const ::CORBA::WChar * TagStereo3D;

  typedef ::CORBA::Short FormatCode;
  typedef ::CORBA::Short_out FormatCode_out;

  class FormatCodes_var;

  class FormatCodes : public _CORBA_Unbounded_Sequence_w_FixSizeElement< FormatCode, 2, 2 >  {
  public:
    typedef FormatCodes_var _var_type;
    inline FormatCodes() {}
    inline FormatCodes(const FormatCodes& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< FormatCode, 2, 2 > (_s) {}

    inline FormatCodes(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< FormatCode, 2, 2 > (_max) {}
    inline FormatCodes(_CORBA_ULong _max, _CORBA_ULong _len, FormatCode* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< FormatCode, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline FormatCodes& operator = (const FormatCodes& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< FormatCode, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class FormatCodes_out;

  class FormatCodes_var {
  public:
    inline FormatCodes_var() : _pd_seq(0) {}
    inline FormatCodes_var(FormatCodes* _s) : _pd_seq(_s) {}
    inline FormatCodes_var(const FormatCodes_var& _s) {
      if( _s._pd_seq )  _pd_seq = new FormatCodes(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~FormatCodes_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline FormatCodes_var& operator = (FormatCodes* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FormatCodes_var& operator = (const FormatCodes_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new FormatCodes;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline FormatCode& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FormatCodes* operator -> () { return _pd_seq; }
    inline const FormatCodes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FormatCodes& () const { return *_pd_seq; }
#else
    inline operator const FormatCodes& () const { return *_pd_seq; }
    inline operator FormatCodes& () { return *_pd_seq; }
#endif
      
    inline const FormatCodes& in() const { return *_pd_seq; }
    inline FormatCodes&       inout()    { return *_pd_seq; }
    inline FormatCodes*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FormatCodes* _retn() { FormatCodes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FormatCodes_out;
    
  private:
    FormatCodes* _pd_seq;
  };

  class FormatCodes_out {
  public:
    inline FormatCodes_out(FormatCodes*& _s) : _data(_s) { _data = 0; }
    inline FormatCodes_out(FormatCodes_var& _s)
      : _data(_s._pd_seq) { _s = (FormatCodes*) 0; }
    inline FormatCodes_out(const FormatCodes_out& _s) : _data(_s._data) {}
    inline FormatCodes_out& operator = (const FormatCodes_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FormatCodes_out& operator = (FormatCodes* _s) {
      _data = _s;
      return *this;
    }
    inline operator FormatCodes*&()  { return _data; }
    inline FormatCodes*& ptr()       { return _data; }
    inline FormatCodes* operator->() { return _data; }

    inline FormatCode& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FormatCodes*& _data;

  private:
    FormatCodes_out();
    FormatCodes_out& operator=(const FormatCodes_var&);
  };

  class RawData_var;

  class RawData : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef RawData_var _var_type;
    inline RawData() {}
    inline RawData(const RawData& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline RawData(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline RawData(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline RawData& operator = (const RawData& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class RawData_out;

  class RawData_var {
  public:
    inline RawData_var() : _pd_seq(0) {}
    inline RawData_var(RawData* _s) : _pd_seq(_s) {}
    inline RawData_var(const RawData_var& _s) {
      if( _s._pd_seq )  _pd_seq = new RawData(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~RawData_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline RawData_var& operator = (RawData* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline RawData_var& operator = (const RawData_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new RawData;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline RawData* operator -> () { return _pd_seq; }
    inline const RawData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator RawData& () const { return *_pd_seq; }
#else
    inline operator const RawData& () const { return *_pd_seq; }
    inline operator RawData& () { return *_pd_seq; }
#endif
      
    inline const RawData& in() const { return *_pd_seq; }
    inline RawData&       inout()    { return *_pd_seq; }
    inline RawData*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline RawData* _retn() { RawData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class RawData_out;
    
  private:
    RawData* _pd_seq;
  };

  class RawData_out {
  public:
    inline RawData_out(RawData*& _s) : _data(_s) { _data = 0; }
    inline RawData_out(RawData_var& _s)
      : _data(_s._pd_seq) { _s = (RawData*) 0; }
    inline RawData_out(const RawData_out& _s) : _data(_s._data) {}
    inline RawData_out& operator = (const RawData_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline RawData_out& operator = (RawData* _s) {
      _data = _s;
      return *this;
    }
    inline operator RawData*&()  { return _data; }
    inline RawData*& ptr()       { return _data; }
    inline RawData* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    RawData*& _data;

  private:
    RawData_out();
    RawData_out& operator=(const RawData_var&);
  };

  class Longs_var;

  class Longs : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef Longs_var _var_type;
    inline Longs() {}
    inline Longs(const Longs& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline Longs(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline Longs(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline Longs& operator = (const Longs& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class Longs_out;

  class Longs_var {
  public:
    inline Longs_var() : _pd_seq(0) {}
    inline Longs_var(Longs* _s) : _pd_seq(_s) {}
    inline Longs_var(const Longs_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Longs(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Longs_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Longs_var& operator = (Longs* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Longs_var& operator = (const Longs_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Longs;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Longs* operator -> () { return _pd_seq; }
    inline const Longs* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Longs& () const { return *_pd_seq; }
#else
    inline operator const Longs& () const { return *_pd_seq; }
    inline operator Longs& () { return *_pd_seq; }
#endif
      
    inline const Longs& in() const { return *_pd_seq; }
    inline Longs&       inout()    { return *_pd_seq; }
    inline Longs*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Longs* _retn() { Longs* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Longs_out;
    
  private:
    Longs* _pd_seq;
  };

  class Longs_out {
  public:
    inline Longs_out(Longs*& _s) : _data(_s) { _data = 0; }
    inline Longs_out(Longs_var& _s)
      : _data(_s._pd_seq) { _s = (Longs*) 0; }
    inline Longs_out(const Longs_out& _s) : _data(_s._data) {}
    inline Longs_out& operator = (const Longs_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Longs_out& operator = (Longs* _s) {
      _data = _s;
      return *this;
    }
    inline operator Longs*&()  { return _data; }
    inline Longs*& ptr()       { return _data; }
    inline Longs* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Longs*& _data;

  private:
    Longs_out();
    Longs_out& operator=(const Longs_var&);
  };

  class WStrings_var;

  class WStrings : public _CORBA_Unbounded_Sequence_WString {
  public:
    typedef WStrings_var _var_type;
    inline WStrings() {}
    inline WStrings(const WStrings& _s)
      : _CORBA_Unbounded_Sequence_WString(_s) {}

    inline WStrings(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_WString(_max) {}
    inline WStrings(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::WChar** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_WString(_max, _len, _val, _rel) {}

  

    inline WStrings& operator = (const WStrings& _s) {
      _CORBA_Unbounded_Sequence_WString::operator=(_s);
      return *this;
    }
  };

  class WStrings_out;

  class WStrings_var {
  public:
    inline WStrings_var() : _pd_seq(0) {}
    inline WStrings_var(WStrings* _s) : _pd_seq(_s) {}
    inline WStrings_var(const WStrings_var& _s) {
      if( _s._pd_seq )  _pd_seq = new WStrings(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~WStrings_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline WStrings_var& operator = (WStrings* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline WStrings_var& operator = (const WStrings_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new WStrings;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_WString_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline WStrings* operator -> () { return _pd_seq; }
    inline const WStrings* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator WStrings& () const { return *_pd_seq; }
#else
    inline operator const WStrings& () const { return *_pd_seq; }
    inline operator WStrings& () { return *_pd_seq; }
#endif
      
    inline const WStrings& in() const { return *_pd_seq; }
    inline WStrings&       inout()    { return *_pd_seq; }
    inline WStrings*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline WStrings* _retn() { WStrings* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class WStrings_out;
    
  private:
    WStrings* _pd_seq;
  };

  class WStrings_out {
  public:
    inline WStrings_out(WStrings*& _s) : _data(_s) { _data = 0; }
    inline WStrings_out(WStrings_var& _s)
      : _data(_s._pd_seq) { _s = (WStrings*) 0; }
    inline WStrings_out(const WStrings_out& _s) : _data(_s._data) {}
    inline WStrings_out& operator = (const WStrings_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline WStrings_out& operator = (WStrings* _s) {
      _data = _s;
      return *this;
    }
    inline operator WStrings*&()  { return _data; }
    inline WStrings*& ptr()       { return _data; }
    inline WStrings* operator->() { return _data; }

    inline _CORBA_WString_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    WStrings*& _data;

  private:
    WStrings_out();
    WStrings_out& operator=(const WStrings_var&);
  };

  typedef ::CORBA::Long Timecode;
  typedef ::CORBA::Long_out Timecode_out;

  struct RushIdent {
    typedef _CORBA_ConstrType_Fix_Var<RushIdent> _var_type;

    
    ::CORBA::LongLong first;

    ::CORBA::LongLong second;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RushIdent::_var_type RushIdent_var;

  typedef RushIdent& RushIdent_out;

  struct ClipProperty {
    typedef _CORBA_ConstrType_Variable_Var<ClipProperty> _var_type;

    
    ::CORBA::WString_member name;

    ::CORBA::WString_member value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ClipProperty::_var_type ClipProperty_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ClipProperty,ClipProperty_var > ClipProperty_out;

  class ClipPropertyList_var;

  class ClipPropertyList : public _CORBA_Unbounded_Sequence< ClipProperty >  {
  public:
    typedef ClipPropertyList_var _var_type;
    inline ClipPropertyList() {}
    inline ClipPropertyList(const ClipPropertyList& _s)
      : _CORBA_Unbounded_Sequence< ClipProperty > (_s) {}

    inline ClipPropertyList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ClipProperty > (_max) {}
    inline ClipPropertyList(_CORBA_ULong _max, _CORBA_ULong _len, ClipProperty* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ClipProperty > (_max, _len, _val, _rel) {}

  

    inline ClipPropertyList& operator = (const ClipPropertyList& _s) {
      _CORBA_Unbounded_Sequence< ClipProperty > ::operator=(_s);
      return *this;
    }
  };

  class ClipPropertyList_out;

  class ClipPropertyList_var {
  public:
    inline ClipPropertyList_var() : _pd_seq(0) {}
    inline ClipPropertyList_var(ClipPropertyList* _s) : _pd_seq(_s) {}
    inline ClipPropertyList_var(const ClipPropertyList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ClipPropertyList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ClipPropertyList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ClipPropertyList_var& operator = (ClipPropertyList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ClipPropertyList_var& operator = (const ClipPropertyList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ClipPropertyList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ClipProperty& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ClipPropertyList* operator -> () { return _pd_seq; }
    inline const ClipPropertyList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ClipPropertyList& () const { return *_pd_seq; }
#else
    inline operator const ClipPropertyList& () const { return *_pd_seq; }
    inline operator ClipPropertyList& () { return *_pd_seq; }
#endif
      
    inline const ClipPropertyList& in() const { return *_pd_seq; }
    inline ClipPropertyList&       inout()    { return *_pd_seq; }
    inline ClipPropertyList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ClipPropertyList* _retn() { ClipPropertyList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ClipPropertyList_out;
    
  private:
    ClipPropertyList* _pd_seq;
  };

  class ClipPropertyList_out {
  public:
    inline ClipPropertyList_out(ClipPropertyList*& _s) : _data(_s) { _data = 0; }
    inline ClipPropertyList_out(ClipPropertyList_var& _s)
      : _data(_s._pd_seq) { _s = (ClipPropertyList*) 0; }
    inline ClipPropertyList_out(const ClipPropertyList_out& _s) : _data(_s._data) {}
    inline ClipPropertyList_out& operator = (const ClipPropertyList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ClipPropertyList_out& operator = (ClipPropertyList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ClipPropertyList*&()  { return _data; }
    inline ClipPropertyList*& ptr()       { return _data; }
    inline ClipPropertyList* operator->() { return _data; }

    inline ClipProperty& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ClipPropertyList*& _data;

  private:
    ClipPropertyList_out();
    ClipPropertyList_out& operator=(const ClipPropertyList_var&);
  };

  enum SortDirection { ascending, descending /*, __max_SortDirection=0xffffffff */ };
  typedef SortDirection& SortDirection_out;

  struct SortOrder {
    typedef _CORBA_ConstrType_Variable_Var<SortOrder> _var_type;

    
    ::CORBA::WString_member name;

    SortDirection direction;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef SortOrder::_var_type SortOrder_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< SortOrder,SortOrder_var > SortOrder_out;

  class SortOrderList_var;

  class SortOrderList : public _CORBA_Unbounded_Sequence< SortOrder >  {
  public:
    typedef SortOrderList_var _var_type;
    inline SortOrderList() {}
    inline SortOrderList(const SortOrderList& _s)
      : _CORBA_Unbounded_Sequence< SortOrder > (_s) {}

    inline SortOrderList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< SortOrder > (_max) {}
    inline SortOrderList(_CORBA_ULong _max, _CORBA_ULong _len, SortOrder* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< SortOrder > (_max, _len, _val, _rel) {}

  

    inline SortOrderList& operator = (const SortOrderList& _s) {
      _CORBA_Unbounded_Sequence< SortOrder > ::operator=(_s);
      return *this;
    }
  };

  class SortOrderList_out;

  class SortOrderList_var {
  public:
    inline SortOrderList_var() : _pd_seq(0) {}
    inline SortOrderList_var(SortOrderList* _s) : _pd_seq(_s) {}
    inline SortOrderList_var(const SortOrderList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new SortOrderList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~SortOrderList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline SortOrderList_var& operator = (SortOrderList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline SortOrderList_var& operator = (const SortOrderList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new SortOrderList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline SortOrder& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline SortOrderList* operator -> () { return _pd_seq; }
    inline const SortOrderList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator SortOrderList& () const { return *_pd_seq; }
#else
    inline operator const SortOrderList& () const { return *_pd_seq; }
    inline operator SortOrderList& () { return *_pd_seq; }
#endif
      
    inline const SortOrderList& in() const { return *_pd_seq; }
    inline SortOrderList&       inout()    { return *_pd_seq; }
    inline SortOrderList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline SortOrderList* _retn() { SortOrderList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class SortOrderList_out;
    
  private:
    SortOrderList* _pd_seq;
  };

  class SortOrderList_out {
  public:
    inline SortOrderList_out(SortOrderList*& _s) : _data(_s) { _data = 0; }
    inline SortOrderList_out(SortOrderList_var& _s)
      : _data(_s._pd_seq) { _s = (SortOrderList*) 0; }
    inline SortOrderList_out(const SortOrderList_out& _s) : _data(_s._data) {}
    inline SortOrderList_out& operator = (const SortOrderList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline SortOrderList_out& operator = (SortOrderList* _s) {
      _data = _s;
      return *this;
    }
    inline operator SortOrderList*&()  { return _data; }
    inline SortOrderList*& ptr()       { return _data; }
    inline SortOrderList* operator->() { return _data; }

    inline SortOrder& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    SortOrderList*& _data;

  private:
    SortOrderList_out();
    SortOrderList_out& operator=(const SortOrderList_var&);
  };

  enum ProtectMode { protectReadWrite, protectReadOnly, protectDelete /*, __max_ProtectMode=0xffffffff */ };
  typedef ProtectMode& ProtectMode_out;

  struct ServerInfo {
    typedef _CORBA_ConstrType_Variable_Var<ServerInfo> _var_type;

    
    ::CORBA::Long ident;

    ::CORBA::Boolean down;

    ::CORBA::Long numChannels;

    Longs pools;

    ::CORBA::WString_member name;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerInfo::_var_type ServerInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServerInfo,ServerInfo_var > ServerInfo_out;

  struct PoolInfo {
    typedef _CORBA_ConstrType_Variable_Var<PoolInfo> _var_type;

    
    ::CORBA::Boolean down;

    ::CORBA::Long ident;

    ::CORBA::LongLong capacity;

    ::CORBA::WString_member name;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PoolInfo::_var_type PoolInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PoolInfo,PoolInfo_var > PoolInfo_out;

  struct PortInfo {
    typedef _CORBA_ConstrType_Variable_Var<PortInfo> _var_type;

    
    _CORBA_ObjRef_Member< _objref_Server, Server_Helper>  portServer;

    ::CORBA::Long serverIdent;

    ::CORBA::WString_member name;

    ::CORBA::Long number;

    Longs numTracks;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PortInfo::_var_type PortInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PortInfo,PortInfo_var > PortInfo_out;

  enum StateChangeType { clipCreated, clipModified, clipHidden, clipDeleted, serverUp, serverDown, serverChanged, poolUp, poolDown, listenerGone, copyComplete, copyFailed, zoneUp, zoneDown, zoneFailover, aafUpdated /*, __max_StateChangeType=0xffffffff */ };
  typedef StateChangeType& StateChangeType_out;

  struct StateChangeInfo {
    typedef _CORBA_ConstrType_Fix_Var<StateChangeInfo> _var_type;

    
    StateChangeType type;

    ::CORBA::Long ident;

    ::CORBA::Long changeNum;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef StateChangeInfo::_var_type StateChangeInfo_var;

  typedef StateChangeInfo& StateChangeInfo_out;

  class StateChangeList_var;

  class StateChangeList : public _CORBA_Unbounded_Sequence< StateChangeInfo >  {
  public:
    typedef StateChangeList_var _var_type;
    inline StateChangeList() {}
    inline StateChangeList(const StateChangeList& _s)
      : _CORBA_Unbounded_Sequence< StateChangeInfo > (_s) {}

    inline StateChangeList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< StateChangeInfo > (_max) {}
    inline StateChangeList(_CORBA_ULong _max, _CORBA_ULong _len, StateChangeInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< StateChangeInfo > (_max, _len, _val, _rel) {}

  

    inline StateChangeList& operator = (const StateChangeList& _s) {
      _CORBA_Unbounded_Sequence< StateChangeInfo > ::operator=(_s);
      return *this;
    }
  };

  class StateChangeList_out;

  class StateChangeList_var {
  public:
    inline StateChangeList_var() : _pd_seq(0) {}
    inline StateChangeList_var(StateChangeList* _s) : _pd_seq(_s) {}
    inline StateChangeList_var(const StateChangeList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new StateChangeList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~StateChangeList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline StateChangeList_var& operator = (StateChangeList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StateChangeList_var& operator = (const StateChangeList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new StateChangeList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline StateChangeInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StateChangeList* operator -> () { return _pd_seq; }
    inline const StateChangeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StateChangeList& () const { return *_pd_seq; }
#else
    inline operator const StateChangeList& () const { return *_pd_seq; }
    inline operator StateChangeList& () { return *_pd_seq; }
#endif
      
    inline const StateChangeList& in() const { return *_pd_seq; }
    inline StateChangeList&       inout()    { return *_pd_seq; }
    inline StateChangeList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StateChangeList* _retn() { StateChangeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StateChangeList_out;
    
  private:
    StateChangeList* _pd_seq;
  };

  class StateChangeList_out {
  public:
    inline StateChangeList_out(StateChangeList*& _s) : _data(_s) { _data = 0; }
    inline StateChangeList_out(StateChangeList_var& _s)
      : _data(_s._pd_seq) { _s = (StateChangeList*) 0; }
    inline StateChangeList_out(const StateChangeList_out& _s) : _data(_s._data) {}
    inline StateChangeList_out& operator = (const StateChangeList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StateChangeList_out& operator = (StateChangeList* _s) {
      _data = _s;
      return *this;
    }
    inline operator StateChangeList*&()  { return _data; }
    inline StateChangeList*& ptr()       { return _data; }
    inline StateChangeList* operator->() { return _data; }

    inline StateChangeInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StateChangeList*& _data;

  private:
    StateChangeList_out();
    StateChangeList_out& operator=(const StateChangeList_var&);
  };

  struct CopyProgress {
    typedef _CORBA_ConstrType_Fix_Var<CopyProgress> _var_type;

    
    ::CORBA::Long clipID;

    ::CORBA::Long totalProtons;

    ::CORBA::Long protonsLeft;

    ::CORBA::Long secsLeft;

    ::CORBA::Long priority;

    ::CORBA::Boolean ticketed;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef CopyProgress::_var_type CopyProgress_var;

  typedef CopyProgress& CopyProgress_out;

  class CopyProgressList_var;

  class CopyProgressList : public _CORBA_Unbounded_Sequence< CopyProgress >  {
  public:
    typedef CopyProgressList_var _var_type;
    inline CopyProgressList() {}
    inline CopyProgressList(const CopyProgressList& _s)
      : _CORBA_Unbounded_Sequence< CopyProgress > (_s) {}

    inline CopyProgressList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< CopyProgress > (_max) {}
    inline CopyProgressList(_CORBA_ULong _max, _CORBA_ULong _len, CopyProgress* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< CopyProgress > (_max, _len, _val, _rel) {}

  

    inline CopyProgressList& operator = (const CopyProgressList& _s) {
      _CORBA_Unbounded_Sequence< CopyProgress > ::operator=(_s);
      return *this;
    }
  };

  class CopyProgressList_out;

  class CopyProgressList_var {
  public:
    inline CopyProgressList_var() : _pd_seq(0) {}
    inline CopyProgressList_var(CopyProgressList* _s) : _pd_seq(_s) {}
    inline CopyProgressList_var(const CopyProgressList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new CopyProgressList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~CopyProgressList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline CopyProgressList_var& operator = (CopyProgressList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CopyProgressList_var& operator = (const CopyProgressList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new CopyProgressList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline CopyProgress& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CopyProgressList* operator -> () { return _pd_seq; }
    inline const CopyProgressList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CopyProgressList& () const { return *_pd_seq; }
#else
    inline operator const CopyProgressList& () const { return *_pd_seq; }
    inline operator CopyProgressList& () { return *_pd_seq; }
#endif
      
    inline const CopyProgressList& in() const { return *_pd_seq; }
    inline CopyProgressList&       inout()    { return *_pd_seq; }
    inline CopyProgressList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CopyProgressList* _retn() { CopyProgressList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CopyProgressList_out;
    
  private:
    CopyProgressList* _pd_seq;
  };

  class CopyProgressList_out {
  public:
    inline CopyProgressList_out(CopyProgressList*& _s) : _data(_s) { _data = 0; }
    inline CopyProgressList_out(CopyProgressList_var& _s)
      : _data(_s._pd_seq) { _s = (CopyProgressList*) 0; }
    inline CopyProgressList_out(const CopyProgressList_out& _s) : _data(_s._data) {}
    inline CopyProgressList_out& operator = (const CopyProgressList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CopyProgressList_out& operator = (CopyProgressList* _s) {
      _data = _s;
      return *this;
    }
    inline operator CopyProgressList*&()  { return _data; }
    inline CopyProgressList*& ptr()       { return _data; }
    inline CopyProgressList* operator->() { return _data; }

    inline CopyProgress& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CopyProgressList*& _data;

  private:
    CopyProgressList_out();
    CopyProgressList_out& operator=(const CopyProgressList_var&);
  };

  struct CopyMapElement {
    typedef _CORBA_ConstrType_Fix_Var<CopyMapElement> _var_type;

    
    ::CORBA::Long flags;

    ::CORBA::Long protons;

    ::CORBA::Long frames;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef CopyMapElement::_var_type CopyMapElement_var;

  typedef CopyMapElement& CopyMapElement_out;

  class CopyMapList_var;

  class CopyMapList : public _CORBA_Unbounded_Sequence< CopyMapElement >  {
  public:
    typedef CopyMapList_var _var_type;
    inline CopyMapList() {}
    inline CopyMapList(const CopyMapList& _s)
      : _CORBA_Unbounded_Sequence< CopyMapElement > (_s) {}

    inline CopyMapList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< CopyMapElement > (_max) {}
    inline CopyMapList(_CORBA_ULong _max, _CORBA_ULong _len, CopyMapElement* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< CopyMapElement > (_max, _len, _val, _rel) {}

  

    inline CopyMapList& operator = (const CopyMapList& _s) {
      _CORBA_Unbounded_Sequence< CopyMapElement > ::operator=(_s);
      return *this;
    }
  };

  class CopyMapList_out;

  class CopyMapList_var {
  public:
    inline CopyMapList_var() : _pd_seq(0) {}
    inline CopyMapList_var(CopyMapList* _s) : _pd_seq(_s) {}
    inline CopyMapList_var(const CopyMapList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new CopyMapList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~CopyMapList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline CopyMapList_var& operator = (CopyMapList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CopyMapList_var& operator = (const CopyMapList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new CopyMapList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline CopyMapElement& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CopyMapList* operator -> () { return _pd_seq; }
    inline const CopyMapList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CopyMapList& () const { return *_pd_seq; }
#else
    inline operator const CopyMapList& () const { return *_pd_seq; }
    inline operator CopyMapList& () { return *_pd_seq; }
#endif
      
    inline const CopyMapList& in() const { return *_pd_seq; }
    inline CopyMapList&       inout()    { return *_pd_seq; }
    inline CopyMapList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CopyMapList* _retn() { CopyMapList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CopyMapList_out;
    
  private:
    CopyMapList* _pd_seq;
  };

  class CopyMapList_out {
  public:
    inline CopyMapList_out(CopyMapList*& _s) : _data(_s) { _data = 0; }
    inline CopyMapList_out(CopyMapList_var& _s)
      : _data(_s._pd_seq) { _s = (CopyMapList*) 0; }
    inline CopyMapList_out(const CopyMapList_out& _s) : _data(_s._data) {}
    inline CopyMapList_out& operator = (const CopyMapList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CopyMapList_out& operator = (CopyMapList* _s) {
      _data = _s;
      return *this;
    }
    inline operator CopyMapList*&()  { return _data; }
    inline CopyMapList*& ptr()       { return _data; }
    inline CopyMapList* operator->() { return _data; }

    inline CopyMapElement& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CopyMapList*& _data;

  private:
    CopyMapList_out();
    CopyMapList_out& operator=(const CopyMapList_var&);
  };

  struct RushTag {
    typedef _CORBA_ConstrType_Variable_Var<RushTag> _var_type;

    
    RushIdent rushID;

    ::CORBA::Long start;

    ::CORBA::Long finish;

    ::CORBA::WString_member tagtype;

    ::CORBA::WString_member info;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RushTag::_var_type RushTag_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< RushTag,RushTag_var > RushTag_out;

  class RushTagList_var;

  class RushTagList : public _CORBA_Unbounded_Sequence< RushTag >  {
  public:
    typedef RushTagList_var _var_type;
    inline RushTagList() {}
    inline RushTagList(const RushTagList& _s)
      : _CORBA_Unbounded_Sequence< RushTag > (_s) {}

    inline RushTagList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< RushTag > (_max) {}
    inline RushTagList(_CORBA_ULong _max, _CORBA_ULong _len, RushTag* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< RushTag > (_max, _len, _val, _rel) {}

  

    inline RushTagList& operator = (const RushTagList& _s) {
      _CORBA_Unbounded_Sequence< RushTag > ::operator=(_s);
      return *this;
    }
  };

  class RushTagList_out;

  class RushTagList_var {
  public:
    inline RushTagList_var() : _pd_seq(0) {}
    inline RushTagList_var(RushTagList* _s) : _pd_seq(_s) {}
    inline RushTagList_var(const RushTagList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new RushTagList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~RushTagList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline RushTagList_var& operator = (RushTagList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline RushTagList_var& operator = (const RushTagList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new RushTagList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline RushTag& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline RushTagList* operator -> () { return _pd_seq; }
    inline const RushTagList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator RushTagList& () const { return *_pd_seq; }
#else
    inline operator const RushTagList& () const { return *_pd_seq; }
    inline operator RushTagList& () { return *_pd_seq; }
#endif
      
    inline const RushTagList& in() const { return *_pd_seq; }
    inline RushTagList&       inout()    { return *_pd_seq; }
    inline RushTagList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline RushTagList* _retn() { RushTagList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class RushTagList_out;
    
  private:
    RushTagList* _pd_seq;
  };

  class RushTagList_out {
  public:
    inline RushTagList_out(RushTagList*& _s) : _data(_s) { _data = 0; }
    inline RushTagList_out(RushTagList_var& _s)
      : _data(_s._pd_seq) { _s = (RushTagList*) 0; }
    inline RushTagList_out(const RushTagList_out& _s) : _data(_s._data) {}
    inline RushTagList_out& operator = (const RushTagList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline RushTagList_out& operator = (RushTagList* _s) {
      _data = _s;
      return *this;
    }
    inline operator RushTagList*&()  { return _data; }
    inline RushTagList*& ptr()       { return _data; }
    inline RushTagList* operator->() { return _data; }

    inline RushTag& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    RushTagList*& _data;

  private:
    RushTagList_out();
    RushTagList_out& operator=(const RushTagList_var&);
  };

  struct RushTimecode {
    typedef _CORBA_ConstrType_Fix_Var<RushTimecode> _var_type;

    
    ::CORBA::Long start;

    ::CORBA::Long finish;

    Timecode portTimecode;

    ::CORBA::Long userBits;

    Timecode refTimecode;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RushTimecode::_var_type RushTimecode_var;

  typedef RushTimecode& RushTimecode_out;

  class RushTimecodeList_var;

  class RushTimecodeList : public _CORBA_Unbounded_Sequence< RushTimecode >  {
  public:
    typedef RushTimecodeList_var _var_type;
    inline RushTimecodeList() {}
    inline RushTimecodeList(const RushTimecodeList& _s)
      : _CORBA_Unbounded_Sequence< RushTimecode > (_s) {}

    inline RushTimecodeList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< RushTimecode > (_max) {}
    inline RushTimecodeList(_CORBA_ULong _max, _CORBA_ULong _len, RushTimecode* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< RushTimecode > (_max, _len, _val, _rel) {}

  

    inline RushTimecodeList& operator = (const RushTimecodeList& _s) {
      _CORBA_Unbounded_Sequence< RushTimecode > ::operator=(_s);
      return *this;
    }
  };

  class RushTimecodeList_out;

  class RushTimecodeList_var {
  public:
    inline RushTimecodeList_var() : _pd_seq(0) {}
    inline RushTimecodeList_var(RushTimecodeList* _s) : _pd_seq(_s) {}
    inline RushTimecodeList_var(const RushTimecodeList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new RushTimecodeList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~RushTimecodeList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline RushTimecodeList_var& operator = (RushTimecodeList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline RushTimecodeList_var& operator = (const RushTimecodeList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new RushTimecodeList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline RushTimecode& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline RushTimecodeList* operator -> () { return _pd_seq; }
    inline const RushTimecodeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator RushTimecodeList& () const { return *_pd_seq; }
#else
    inline operator const RushTimecodeList& () const { return *_pd_seq; }
    inline operator RushTimecodeList& () { return *_pd_seq; }
#endif
      
    inline const RushTimecodeList& in() const { return *_pd_seq; }
    inline RushTimecodeList&       inout()    { return *_pd_seq; }
    inline RushTimecodeList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline RushTimecodeList* _retn() { RushTimecodeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class RushTimecodeList_out;
    
  private:
    RushTimecodeList* _pd_seq;
  };

  class RushTimecodeList_out {
  public:
    inline RushTimecodeList_out(RushTimecodeList*& _s) : _data(_s) { _data = 0; }
    inline RushTimecodeList_out(RushTimecodeList_var& _s)
      : _data(_s._pd_seq) { _s = (RushTimecodeList*) 0; }
    inline RushTimecodeList_out(const RushTimecodeList_out& _s) : _data(_s._data) {}
    inline RushTimecodeList_out& operator = (const RushTimecodeList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline RushTimecodeList_out& operator = (RushTimecodeList* _s) {
      _data = _s;
      return *this;
    }
    inline operator RushTimecodeList*&()  { return _data; }
    inline RushTimecodeList*& ptr()       { return _data; }
    inline RushTimecodeList* operator->() { return _data; }

    inline RushTimecode& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    RushTimecodeList*& _data;

  private:
    RushTimecodeList_out();
    RushTimecodeList_out& operator=(const RushTimecodeList_var&);
  };

  struct ColumnDesc {
    typedef _CORBA_ConstrType_Variable_Var<ColumnDesc> _var_type;

    
    ::CORBA::WString_member columnName;

    ::CORBA::WString_member columnType;

    ::CORBA::WString_member alias;

    ::CORBA::Boolean alterable;

    ::CORBA::Boolean creatable;

    ::CORBA::Boolean searchable;

    ::CORBA::Boolean clones;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ColumnDesc::_var_type ColumnDesc_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ColumnDesc,ColumnDesc_var > ColumnDesc_out;

  class ColumnDescList_var;

  class ColumnDescList : public _CORBA_Unbounded_Sequence< ColumnDesc >  {
  public:
    typedef ColumnDescList_var _var_type;
    inline ColumnDescList() {}
    inline ColumnDescList(const ColumnDescList& _s)
      : _CORBA_Unbounded_Sequence< ColumnDesc > (_s) {}

    inline ColumnDescList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ColumnDesc > (_max) {}
    inline ColumnDescList(_CORBA_ULong _max, _CORBA_ULong _len, ColumnDesc* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ColumnDesc > (_max, _len, _val, _rel) {}

  

    inline ColumnDescList& operator = (const ColumnDescList& _s) {
      _CORBA_Unbounded_Sequence< ColumnDesc > ::operator=(_s);
      return *this;
    }
  };

  class ColumnDescList_out;

  class ColumnDescList_var {
  public:
    inline ColumnDescList_var() : _pd_seq(0) {}
    inline ColumnDescList_var(ColumnDescList* _s) : _pd_seq(_s) {}
    inline ColumnDescList_var(const ColumnDescList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ColumnDescList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ColumnDescList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ColumnDescList_var& operator = (ColumnDescList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ColumnDescList_var& operator = (const ColumnDescList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ColumnDescList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ColumnDesc& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ColumnDescList* operator -> () { return _pd_seq; }
    inline const ColumnDescList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ColumnDescList& () const { return *_pd_seq; }
#else
    inline operator const ColumnDescList& () const { return *_pd_seq; }
    inline operator ColumnDescList& () { return *_pd_seq; }
#endif
      
    inline const ColumnDescList& in() const { return *_pd_seq; }
    inline ColumnDescList&       inout()    { return *_pd_seq; }
    inline ColumnDescList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ColumnDescList* _retn() { ColumnDescList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ColumnDescList_out;
    
  private:
    ColumnDescList* _pd_seq;
  };

  class ColumnDescList_out {
  public:
    inline ColumnDescList_out(ColumnDescList*& _s) : _data(_s) { _data = 0; }
    inline ColumnDescList_out(ColumnDescList_var& _s)
      : _data(_s._pd_seq) { _s = (ColumnDescList*) 0; }
    inline ColumnDescList_out(const ColumnDescList_out& _s) : _data(_s._data) {}
    inline ColumnDescList_out& operator = (const ColumnDescList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ColumnDescList_out& operator = (ColumnDescList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ColumnDescList*&()  { return _data; }
    inline ColumnDescList*& ptr()       { return _data; }
    inline ColumnDescList* operator->() { return _data; }

    inline ColumnDesc& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ColumnDescList*& _data;

  private:
    ColumnDescList_out();
    ColumnDescList_out& operator=(const ColumnDescList_var&);
  };

  struct ConfigDescription {
    typedef _CORBA_ConstrType_Variable_Var<ConfigDescription> _var_type;

    
    ::CORBA::WString_member description;

    ::CORBA::Long configNumber;

    ::CORBA::Float protonsPerFrame;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ConfigDescription::_var_type ConfigDescription_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ConfigDescription,ConfigDescription_var > ConfigDescription_out;

  class ConfigDescriptionList_var;

  class ConfigDescriptionList : public _CORBA_Unbounded_Sequence< ConfigDescription >  {
  public:
    typedef ConfigDescriptionList_var _var_type;
    inline ConfigDescriptionList() {}
    inline ConfigDescriptionList(const ConfigDescriptionList& _s)
      : _CORBA_Unbounded_Sequence< ConfigDescription > (_s) {}

    inline ConfigDescriptionList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ConfigDescription > (_max) {}
    inline ConfigDescriptionList(_CORBA_ULong _max, _CORBA_ULong _len, ConfigDescription* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ConfigDescription > (_max, _len, _val, _rel) {}

  

    inline ConfigDescriptionList& operator = (const ConfigDescriptionList& _s) {
      _CORBA_Unbounded_Sequence< ConfigDescription > ::operator=(_s);
      return *this;
    }
  };

  class ConfigDescriptionList_out;

  class ConfigDescriptionList_var {
  public:
    inline ConfigDescriptionList_var() : _pd_seq(0) {}
    inline ConfigDescriptionList_var(ConfigDescriptionList* _s) : _pd_seq(_s) {}
    inline ConfigDescriptionList_var(const ConfigDescriptionList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ConfigDescriptionList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ConfigDescriptionList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ConfigDescriptionList_var& operator = (ConfigDescriptionList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ConfigDescriptionList_var& operator = (const ConfigDescriptionList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ConfigDescriptionList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ConfigDescription& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ConfigDescriptionList* operator -> () { return _pd_seq; }
    inline const ConfigDescriptionList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ConfigDescriptionList& () const { return *_pd_seq; }
#else
    inline operator const ConfigDescriptionList& () const { return *_pd_seq; }
    inline operator ConfigDescriptionList& () { return *_pd_seq; }
#endif
      
    inline const ConfigDescriptionList& in() const { return *_pd_seq; }
    inline ConfigDescriptionList&       inout()    { return *_pd_seq; }
    inline ConfigDescriptionList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ConfigDescriptionList* _retn() { ConfigDescriptionList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ConfigDescriptionList_out;
    
  private:
    ConfigDescriptionList* _pd_seq;
  };

  class ConfigDescriptionList_out {
  public:
    inline ConfigDescriptionList_out(ConfigDescriptionList*& _s) : _data(_s) { _data = 0; }
    inline ConfigDescriptionList_out(ConfigDescriptionList_var& _s)
      : _data(_s._pd_seq) { _s = (ConfigDescriptionList*) 0; }
    inline ConfigDescriptionList_out(const ConfigDescriptionList_out& _s) : _data(_s._data) {}
    inline ConfigDescriptionList_out& operator = (const ConfigDescriptionList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ConfigDescriptionList_out& operator = (ConfigDescriptionList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ConfigDescriptionList*&()  { return _data; }
    inline ConfigDescriptionList*& ptr()       { return _data; }
    inline ConfigDescriptionList* operator->() { return _data; }

    inline ConfigDescription& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ConfigDescriptionList*& _data;

  private:
    ConfigDescriptionList_out();
    ConfigDescriptionList_out& operator=(const ConfigDescriptionList_var&);
  };

  struct FullClipID {
    typedef _CORBA_ConstrType_Fix_Var<FullClipID> _var_type;

    
    ::CORBA::Long zone;

    ::CORBA::Long clipID;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FullClipID::_var_type FullClipID_var;

  typedef FullClipID& FullClipID_out;

  class FullClipIDList_var;

  class FullClipIDList : public _CORBA_Unbounded_Sequence< FullClipID >  {
  public:
    typedef FullClipIDList_var _var_type;
    inline FullClipIDList() {}
    inline FullClipIDList(const FullClipIDList& _s)
      : _CORBA_Unbounded_Sequence< FullClipID > (_s) {}

    inline FullClipIDList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< FullClipID > (_max) {}
    inline FullClipIDList(_CORBA_ULong _max, _CORBA_ULong _len, FullClipID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< FullClipID > (_max, _len, _val, _rel) {}

  

    inline FullClipIDList& operator = (const FullClipIDList& _s) {
      _CORBA_Unbounded_Sequence< FullClipID > ::operator=(_s);
      return *this;
    }
  };

  class FullClipIDList_out;

  class FullClipIDList_var {
  public:
    inline FullClipIDList_var() : _pd_seq(0) {}
    inline FullClipIDList_var(FullClipIDList* _s) : _pd_seq(_s) {}
    inline FullClipIDList_var(const FullClipIDList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new FullClipIDList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~FullClipIDList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline FullClipIDList_var& operator = (FullClipIDList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FullClipIDList_var& operator = (const FullClipIDList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new FullClipIDList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline FullClipID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FullClipIDList* operator -> () { return _pd_seq; }
    inline const FullClipIDList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FullClipIDList& () const { return *_pd_seq; }
#else
    inline operator const FullClipIDList& () const { return *_pd_seq; }
    inline operator FullClipIDList& () { return *_pd_seq; }
#endif
      
    inline const FullClipIDList& in() const { return *_pd_seq; }
    inline FullClipIDList&       inout()    { return *_pd_seq; }
    inline FullClipIDList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FullClipIDList* _retn() { FullClipIDList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FullClipIDList_out;
    
  private:
    FullClipIDList* _pd_seq;
  };

  class FullClipIDList_out {
  public:
    inline FullClipIDList_out(FullClipIDList*& _s) : _data(_s) { _data = 0; }
    inline FullClipIDList_out(FullClipIDList_var& _s)
      : _data(_s._pd_seq) { _s = (FullClipIDList*) 0; }
    inline FullClipIDList_out(const FullClipIDList_out& _s) : _data(_s._data) {}
    inline FullClipIDList_out& operator = (const FullClipIDList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FullClipIDList_out& operator = (FullClipIDList* _s) {
      _data = _s;
      return *this;
    }
    inline operator FullClipIDList*&()  { return _data; }
    inline FullClipIDList*& ptr()       { return _data; }
    inline FullClipIDList* operator->() { return _data; }

    inline FullClipID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FullClipIDList*& _data;

  private:
    FullClipIDList_out();
    FullClipIDList_out& operator=(const FullClipIDList_var&);
  };

  struct PlaceholderData {
    typedef _CORBA_ConstrType_Variable_Var<PlaceholderData> _var_type;

    
    ::CORBA::Long clipID;

    ::CORBA::Long poolID;

    ::CORBA::Long zoneID;

    ::CORBA::WString_member extData;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PlaceholderData::_var_type PlaceholderData_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PlaceholderData,PlaceholderData_var > PlaceholderData_out;

  class PlaceholderDataList_var;

  class PlaceholderDataList : public _CORBA_Unbounded_Sequence< PlaceholderData >  {
  public:
    typedef PlaceholderDataList_var _var_type;
    inline PlaceholderDataList() {}
    inline PlaceholderDataList(const PlaceholderDataList& _s)
      : _CORBA_Unbounded_Sequence< PlaceholderData > (_s) {}

    inline PlaceholderDataList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PlaceholderData > (_max) {}
    inline PlaceholderDataList(_CORBA_ULong _max, _CORBA_ULong _len, PlaceholderData* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PlaceholderData > (_max, _len, _val, _rel) {}

  

    inline PlaceholderDataList& operator = (const PlaceholderDataList& _s) {
      _CORBA_Unbounded_Sequence< PlaceholderData > ::operator=(_s);
      return *this;
    }
  };

  class PlaceholderDataList_out;

  class PlaceholderDataList_var {
  public:
    inline PlaceholderDataList_var() : _pd_seq(0) {}
    inline PlaceholderDataList_var(PlaceholderDataList* _s) : _pd_seq(_s) {}
    inline PlaceholderDataList_var(const PlaceholderDataList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new PlaceholderDataList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~PlaceholderDataList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline PlaceholderDataList_var& operator = (PlaceholderDataList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline PlaceholderDataList_var& operator = (const PlaceholderDataList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new PlaceholderDataList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline PlaceholderData& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline PlaceholderDataList* operator -> () { return _pd_seq; }
    inline const PlaceholderDataList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator PlaceholderDataList& () const { return *_pd_seq; }
#else
    inline operator const PlaceholderDataList& () const { return *_pd_seq; }
    inline operator PlaceholderDataList& () { return *_pd_seq; }
#endif
      
    inline const PlaceholderDataList& in() const { return *_pd_seq; }
    inline PlaceholderDataList&       inout()    { return *_pd_seq; }
    inline PlaceholderDataList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline PlaceholderDataList* _retn() { PlaceholderDataList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class PlaceholderDataList_out;
    
  private:
    PlaceholderDataList* _pd_seq;
  };

  class PlaceholderDataList_out {
  public:
    inline PlaceholderDataList_out(PlaceholderDataList*& _s) : _data(_s) { _data = 0; }
    inline PlaceholderDataList_out(PlaceholderDataList_var& _s)
      : _data(_s._pd_seq) { _s = (PlaceholderDataList*) 0; }
    inline PlaceholderDataList_out(const PlaceholderDataList_out& _s) : _data(_s._data) {}
    inline PlaceholderDataList_out& operator = (const PlaceholderDataList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline PlaceholderDataList_out& operator = (PlaceholderDataList* _s) {
      _data = _s;
      return *this;
    }
    inline operator PlaceholderDataList*&()  { return _data; }
    inline PlaceholderDataList*& ptr()       { return _data; }
    inline PlaceholderDataList* operator->() { return _data; }

    inline PlaceholderData& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    PlaceholderDataList*& _data;

  private:
    PlaceholderDataList_out();
    PlaceholderDataList_out& operator=(const PlaceholderDataList_var&);
  };

  enum FragmentType { videoFragment, audioFragment, auxFragment, spare3, spare4, spare5, spare6, spare7, flagsFragment, timecodeFragment, aspectFragment, cropFragment, panZoomFragment, speedFragment, multiCamFragment, ccFragment, noteFragment, effectFragment, numFragmentTypes /*, __max_FragmentType=0xffffffff */ };
  typedef FragmentType& FragmentType_out;

  _CORBA_MODULE_VARINT const ::CORBA::Long lastEssenceTrack _init_in_decl_( = 7 );

  _CORBA_MODULE_VARINT const ::CORBA::Long lastLinearTrack _init_in_decl_( = 14 );

  struct PositionData {
    typedef _CORBA_ConstrType_Fix_Var<PositionData> _var_type;

    
    FormatCode format;

    ::CORBA::Long poolID;

    ::CORBA::LongLong poolFrame;

    ::CORBA::Short skew;

    RushIdent rushID;

    ::CORBA::Long rushFrame;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PositionData::_var_type PositionData_var;

  typedef PositionData& PositionData_out;

  struct ServerFlagsFragment {
    typedef _CORBA_ConstrType_Fix_Var<ServerFlagsFragment> _var_type;

    
    ::CORBA::Long flags;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerFlagsFragment::_var_type ServerFlagsFragment_var;

  typedef ServerFlagsFragment& ServerFlagsFragment_out;

  struct ServerTimecodeFragment {
    typedef _CORBA_ConstrType_Fix_Var<ServerTimecodeFragment> _var_type;

    
    Timecode startTimecode;

    ::CORBA::Long userBits;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerTimecodeFragment::_var_type ServerTimecodeFragment_var;

  typedef ServerTimecodeFragment& ServerTimecodeFragment_out;

  struct ServerAspectFragment {
    typedef _CORBA_ConstrType_Fix_Var<ServerAspectFragment> _var_type;

    
    ::CORBA::Long width;

    ::CORBA::Long height;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerAspectFragment::_var_type ServerAspectFragment_var;

  typedef ServerAspectFragment& ServerAspectFragment_out;

  struct ServerCropFragment {
    typedef _CORBA_ConstrType_Fix_Var<ServerCropFragment> _var_type;

    
    ::CORBA::Long x;

    ::CORBA::Long y;

    ::CORBA::Long width;

    ::CORBA::Long height;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerCropFragment::_var_type ServerCropFragment_var;

  typedef ServerCropFragment& ServerCropFragment_out;

  struct ServerPanZoomFragment {
    typedef _CORBA_ConstrType_Fix_Var<ServerPanZoomFragment> _var_type;

    
    ::CORBA::Long x;

    ::CORBA::Long y;

    ::CORBA::Long hZoom;

    ::CORBA::Long vZoom;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerPanZoomFragment::_var_type ServerPanZoomFragment_var;

  typedef ServerPanZoomFragment& ServerPanZoomFragment_out;

  struct ServerSpeedFragment {
    typedef _CORBA_ConstrType_Fix_Var<ServerSpeedFragment> _var_type;

    
    ::CORBA::Long speed;

    ::CORBA::Long profile;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerSpeedFragment::_var_type ServerSpeedFragment_var;

  typedef ServerSpeedFragment& ServerSpeedFragment_out;

  struct ServerMultiCamFragment {
    typedef _CORBA_ConstrType_Fix_Var<ServerMultiCamFragment> _var_type;

    
    ::CORBA::Long stream;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerMultiCamFragment::_var_type ServerMultiCamFragment_var;

  typedef ServerMultiCamFragment& ServerMultiCamFragment_out;

  struct ServerNoteFragment {
    typedef _CORBA_ConstrType_Variable_Var<ServerNoteFragment> _var_type;

    
    ::CORBA::Long noteID;

    ::CORBA::Long aux;

    ::CORBA::Long mask;

    ::CORBA::WString_member note;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerNoteFragment::_var_type ServerNoteFragment_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServerNoteFragment,ServerNoteFragment_var > ServerNoteFragment_out;

  struct ServerEffectFragment {
    typedef _CORBA_ConstrType_Variable_Var<ServerEffectFragment> _var_type;

    
    ::CORBA::Long effectID;

    RawData effectData;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerEffectFragment::_var_type ServerEffectFragment_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServerEffectFragment,ServerEffectFragment_var > ServerEffectFragment_out;

  _CORBA_MODULE_VARINT const ::CORBA::Long extFragSpeed _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Long extFragPanZoom _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Long extFragMultiCam _init_in_decl_( = 32 );

  _CORBA_MODULE_VARINT const ::CORBA::Long extFragCEA608 _init_in_decl_( = 256 );

  struct ServerCCFragment {
    typedef _CORBA_ConstrType_Variable_Var<ServerCCFragment> _var_type;

    
    RushIdent ccID;

    ::CORBA::Long ccType;

    RawData ccData;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerCCFragment::_var_type ServerCCFragment_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServerCCFragment,ServerCCFragment_var > ServerCCFragment_out;

  class ServerFragmentData {
  public:

    typedef _CORBA_ConstrType_Variable_Var<ServerFragmentData> _var_type;

    

    ServerFragmentData(): _pd__initialised(0) {
      _default();

  
    }
    
    ServerFragmentData(const ServerFragmentData& _value) {
      _pd__initialised = _value._pd__initialised;
      if ((_pd__default = _value._pd__default)) {
        
      }
      else {
        switch(_value._pd__d) {
          case videoFragment: videoFragmentData(_value._pd_videoFragmentData); break;

          case audioFragment: audioFragmentData(_value._pd_audioFragmentData); break;

          case auxFragment: auxFragmentData(_value._pd_auxFragmentData); break;

          case flagsFragment: flagsFragmentData(_value._pd_flagsFragmentData); break;

          case timecodeFragment: timecodeFragmentData(_value._pd_timecodeFragmentData); break;

          case aspectFragment: aspectFragmentData(_value._pd_aspectFragmentData); break;

          case cropFragment: cropFragmentData(_value._pd_cropFragmentData); break;

          case noteFragment: noteFragmentData(_value._pd_noteFragmentData); break;

          case effectFragment: effectFragmentData(_value._pd_effectFragmentData); break;

          case panZoomFragment: panZoomFragmentData(_value._pd_panZoomFragmentData); break;

          case speedFragment: speedFragmentData(_value._pd_speedFragmentData); break;

          case multiCamFragment: multiCamFragmentData(_value._pd_multiCamFragmentData); break;

          case ccFragment: ccFragmentData(_value._pd_ccFragmentData); break;

            default: break;

      
        }
      }
      _pd__d = _value._pd__d;

  
    }

    ~ServerFragmentData() {}

    ServerFragmentData& operator=(const ServerFragmentData& _value) {
      _pd__initialised = _value._pd__initialised;
      if ((_pd__default = _value._pd__default)) {
        
      }
      else {
        switch(_value._pd__d) {
          case videoFragment: videoFragmentData(_value._pd_videoFragmentData); break;

          case audioFragment: audioFragmentData(_value._pd_audioFragmentData); break;

          case auxFragment: auxFragmentData(_value._pd_auxFragmentData); break;

          case flagsFragment: flagsFragmentData(_value._pd_flagsFragmentData); break;

          case timecodeFragment: timecodeFragmentData(_value._pd_timecodeFragmentData); break;

          case aspectFragment: aspectFragmentData(_value._pd_aspectFragmentData); break;

          case cropFragment: cropFragmentData(_value._pd_cropFragmentData); break;

          case noteFragment: noteFragmentData(_value._pd_noteFragmentData); break;

          case effectFragment: effectFragmentData(_value._pd_effectFragmentData); break;

          case panZoomFragment: panZoomFragmentData(_value._pd_panZoomFragmentData); break;

          case speedFragment: speedFragmentData(_value._pd_speedFragmentData); break;

          case multiCamFragment: multiCamFragmentData(_value._pd_multiCamFragmentData); break;

          case ccFragment: ccFragmentData(_value._pd_ccFragmentData); break;

            default: break;

      
        }
      }
      _pd__d = _value._pd__d;

  
      return *this;
    }

    FragmentType _d() const { return _pd__d;}
    void _d(FragmentType _value){
      // illegal to set discriminator before making a member active
      if (!_pd__initialised)
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

      if (_value == _pd__d) return; // no change

      switch (_pd__d){
        case videoFragment: goto fail;
        case audioFragment: goto fail;
        case auxFragment: goto fail;
        case flagsFragment: goto fail;
        case timecodeFragment: goto fail;
        case aspectFragment: goto fail;
        case cropFragment: goto fail;
        case noteFragment: goto fail;
        case effectFragment: goto fail;
        case panZoomFragment: goto fail;
        case speedFragment: goto fail;
        case multiCamFragment: goto fail;
        case ccFragment: goto fail;
        default:
        switch (_value){
          case videoFragment: goto fail;
          case audioFragment: goto fail;
          case auxFragment: goto fail;
          case flagsFragment: goto fail;
          case timecodeFragment: goto fail;
          case aspectFragment: goto fail;
          case cropFragment: goto fail;
          case noteFragment: goto fail;
          case effectFragment: goto fail;
          case panZoomFragment: goto fail;
          case speedFragment: goto fail;
          case multiCamFragment: goto fail;
          case ccFragment: goto fail;
          default: _pd__d = _value; return;
        }

      };
      

      fail:
      OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


  
    }

    void _default()
    {
      _pd__initialised = 1;
      _pd__d = spare3;
      _pd__default = 1;
    }

  

    const PositionData &videoFragmentData () const { return _pd_videoFragmentData; }
    PositionData &videoFragmentData () { return _pd_videoFragmentData; }
    void videoFragmentData (const PositionData& _value) {
      _pd__initialised = 1;
      _pd__d = videoFragment;
      _pd__default = 0;
      _pd_videoFragmentData = _value;
    }

    const PositionData &audioFragmentData () const { return _pd_audioFragmentData; }
    PositionData &audioFragmentData () { return _pd_audioFragmentData; }
    void audioFragmentData (const PositionData& _value) {
      _pd__initialised = 1;
      _pd__d = audioFragment;
      _pd__default = 0;
      _pd_audioFragmentData = _value;
    }

    const PositionData &auxFragmentData () const { return _pd_auxFragmentData; }
    PositionData &auxFragmentData () { return _pd_auxFragmentData; }
    void auxFragmentData (const PositionData& _value) {
      _pd__initialised = 1;
      _pd__d = auxFragment;
      _pd__default = 0;
      _pd_auxFragmentData = _value;
    }

    const ServerFlagsFragment &flagsFragmentData () const { return _pd_flagsFragmentData; }
    ServerFlagsFragment &flagsFragmentData () { return _pd_flagsFragmentData; }
    void flagsFragmentData (const ServerFlagsFragment& _value) {
      _pd__initialised = 1;
      _pd__d = flagsFragment;
      _pd__default = 0;
      _pd_flagsFragmentData = _value;
    }

    const ServerTimecodeFragment &timecodeFragmentData () const { return _pd_timecodeFragmentData; }
    ServerTimecodeFragment &timecodeFragmentData () { return _pd_timecodeFragmentData; }
    void timecodeFragmentData (const ServerTimecodeFragment& _value) {
      _pd__initialised = 1;
      _pd__d = timecodeFragment;
      _pd__default = 0;
      _pd_timecodeFragmentData = _value;
    }

    const ServerAspectFragment &aspectFragmentData () const { return _pd_aspectFragmentData; }
    ServerAspectFragment &aspectFragmentData () { return _pd_aspectFragmentData; }
    void aspectFragmentData (const ServerAspectFragment& _value) {
      _pd__initialised = 1;
      _pd__d = aspectFragment;
      _pd__default = 0;
      _pd_aspectFragmentData = _value;
    }

    const ServerCropFragment &cropFragmentData () const { return _pd_cropFragmentData; }
    ServerCropFragment &cropFragmentData () { return _pd_cropFragmentData; }
    void cropFragmentData (const ServerCropFragment& _value) {
      _pd__initialised = 1;
      _pd__d = cropFragment;
      _pd__default = 0;
      _pd_cropFragmentData = _value;
    }

    const ServerNoteFragment &noteFragmentData () const { return _pd_noteFragmentData; }
    ServerNoteFragment &noteFragmentData () { return _pd_noteFragmentData; }
    void noteFragmentData (const ServerNoteFragment& _value) {
      _pd__initialised = 1;
      _pd__d = noteFragment;
      _pd__default = 0;
      _pd_noteFragmentData = _value;
    }

    const ServerEffectFragment &effectFragmentData () const { return _pd_effectFragmentData; }
    ServerEffectFragment &effectFragmentData () { return _pd_effectFragmentData; }
    void effectFragmentData (const ServerEffectFragment& _value) {
      _pd__initialised = 1;
      _pd__d = effectFragment;
      _pd__default = 0;
      _pd_effectFragmentData = _value;
    }

    const ServerPanZoomFragment &panZoomFragmentData () const { return _pd_panZoomFragmentData; }
    ServerPanZoomFragment &panZoomFragmentData () { return _pd_panZoomFragmentData; }
    void panZoomFragmentData (const ServerPanZoomFragment& _value) {
      _pd__initialised = 1;
      _pd__d = panZoomFragment;
      _pd__default = 0;
      _pd_panZoomFragmentData = _value;
    }

    const ServerSpeedFragment &speedFragmentData () const { return _pd_speedFragmentData; }
    ServerSpeedFragment &speedFragmentData () { return _pd_speedFragmentData; }
    void speedFragmentData (const ServerSpeedFragment& _value) {
      _pd__initialised = 1;
      _pd__d = speedFragment;
      _pd__default = 0;
      _pd_speedFragmentData = _value;
    }

    const ServerMultiCamFragment &multiCamFragmentData () const { return _pd_multiCamFragmentData; }
    ServerMultiCamFragment &multiCamFragmentData () { return _pd_multiCamFragmentData; }
    void multiCamFragmentData (const ServerMultiCamFragment& _value) {
      _pd__initialised = 1;
      _pd__d = multiCamFragment;
      _pd__default = 0;
      _pd_multiCamFragmentData = _value;
    }

    const ServerCCFragment &ccFragmentData () const { return _pd_ccFragmentData; }
    ServerCCFragment &ccFragmentData () { return _pd_ccFragmentData; }
    void ccFragmentData (const ServerCCFragment& _value) {
      _pd__initialised = 1;
      _pd__d = ccFragment;
      _pd__default = 0;
      _pd_ccFragmentData = _value;
    }

  
    
    void operator>>= (cdrStream&) const;
    void operator<<= (cdrStream&);

  private:
    FragmentType _pd__d;
    _CORBA_Boolean _pd__default;
    _CORBA_Boolean _pd__initialised;

    
    PositionData _pd_videoFragmentData;

    PositionData _pd_audioFragmentData;

    PositionData _pd_auxFragmentData;

    ServerFlagsFragment _pd_flagsFragmentData;

    ServerTimecodeFragment _pd_timecodeFragmentData;

    ServerAspectFragment _pd_aspectFragmentData;

    ServerCropFragment _pd_cropFragmentData;

    ServerNoteFragment _pd_noteFragmentData;

    ServerEffectFragment _pd_effectFragmentData;

    ServerPanZoomFragment _pd_panZoomFragmentData;

    ServerSpeedFragment _pd_speedFragmentData;

    ServerMultiCamFragment _pd_multiCamFragmentData;

    ServerCCFragment _pd_ccFragmentData;

  
  };

  typedef ServerFragmentData::_var_type ServerFragmentData_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServerFragmentData,ServerFragmentData_var > ServerFragmentData_out;

  struct ServerFragment {
    typedef _CORBA_ConstrType_Variable_Var<ServerFragment> _var_type;

    
    ::CORBA::Long trackNum;

    ::CORBA::Long start;

    ::CORBA::Long finish;

    ServerFragmentData fragmentData;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerFragment::_var_type ServerFragment_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServerFragment,ServerFragment_var > ServerFragment_out;

  class ServerFragments_var;

  class ServerFragments : public _CORBA_Unbounded_Sequence< ServerFragment >  {
  public:
    typedef ServerFragments_var _var_type;
    inline ServerFragments() {}
    inline ServerFragments(const ServerFragments& _s)
      : _CORBA_Unbounded_Sequence< ServerFragment > (_s) {}

    inline ServerFragments(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ServerFragment > (_max) {}
    inline ServerFragments(_CORBA_ULong _max, _CORBA_ULong _len, ServerFragment* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ServerFragment > (_max, _len, _val, _rel) {}

  

    inline ServerFragments& operator = (const ServerFragments& _s) {
      _CORBA_Unbounded_Sequence< ServerFragment > ::operator=(_s);
      return *this;
    }
  };

  class ServerFragments_out;

  class ServerFragments_var {
  public:
    inline ServerFragments_var() : _pd_seq(0) {}
    inline ServerFragments_var(ServerFragments* _s) : _pd_seq(_s) {}
    inline ServerFragments_var(const ServerFragments_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ServerFragments(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ServerFragments_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ServerFragments_var& operator = (ServerFragments* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ServerFragments_var& operator = (const ServerFragments_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ServerFragments;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ServerFragment& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ServerFragments* operator -> () { return _pd_seq; }
    inline const ServerFragments* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ServerFragments& () const { return *_pd_seq; }
#else
    inline operator const ServerFragments& () const { return *_pd_seq; }
    inline operator ServerFragments& () { return *_pd_seq; }
#endif
      
    inline const ServerFragments& in() const { return *_pd_seq; }
    inline ServerFragments&       inout()    { return *_pd_seq; }
    inline ServerFragments*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ServerFragments* _retn() { ServerFragments* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ServerFragments_out;
    
  private:
    ServerFragments* _pd_seq;
  };

  class ServerFragments_out {
  public:
    inline ServerFragments_out(ServerFragments*& _s) : _data(_s) { _data = 0; }
    inline ServerFragments_out(ServerFragments_var& _s)
      : _data(_s._pd_seq) { _s = (ServerFragments*) 0; }
    inline ServerFragments_out(const ServerFragments_out& _s) : _data(_s._data) {}
    inline ServerFragments_out& operator = (const ServerFragments_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ServerFragments_out& operator = (ServerFragments* _s) {
      _data = _s;
      return *this;
    }
    inline operator ServerFragments*&()  { return _data; }
    inline ServerFragments*& ptr()       { return _data; }
    inline ServerFragments* operator->() { return _data; }

    inline ServerFragment& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ServerFragments*& _data;

  private:
    ServerFragments_out();
    ServerFragments_out& operator=(const ServerFragments_var&);
  };

  struct FormatInfo {
    typedef _CORBA_ConstrType_Variable_Var<FormatInfo> _var_type;

    
    FormatCode formatNumber;

    FragmentType essenceType;

    ::CORBA::Long frameRate;

    ::CORBA::Long height;

    ::CORBA::Long width;

    ::CORBA::Long samples;

    ::CORBA::Long compressionFamily;

    ::CORBA::Long protonsPerAtom;

    ::CORBA::Long framesPerAtom;

    ::CORBA::Long quark;

    ::CORBA::WString_member formatName;

    ::CORBA::WString_member layoutName;

    ::CORBA::WString_member compressionName;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FormatInfo::_var_type FormatInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FormatInfo,FormatInfo_var > FormatInfo_out;

#ifndef __Quentin_mProperties__
#define __Quentin_mProperties__

  class Properties;
  class _objref_Properties;
  class _impl_Properties;
  
  typedef _objref_Properties* Properties_ptr;
  typedef Properties_ptr PropertiesRef;

  class Properties_Helper {
  public:
    typedef Properties_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Properties, Properties_Helper> Properties_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Properties,Properties_Helper > Properties_out;

#endif

  // interface Properties
  class Properties {
  public:
    // Declarations for this interface type.
    typedef Properties_ptr _ptr_type;
    typedef Properties_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _core_attr const ::CORBA::WChar * idlImplementation;

    static _core_attr const ::CORBA::WChar * softwareVersion;

    static _core_attr const ::CORBA::WChar * serialNumber;

    static _core_attr const ::CORBA::WChar * name;

    static _core_attr const ::CORBA::WChar * location;

    static _core_attr const ::CORBA::WChar * frameRate;

    static _core_attr const ::CORBA::WChar * redAlert;

    static _core_attr const ::CORBA::WChar * amberAlert;

    static _core_attr const ::CORBA::WChar * consoleURI;

    static _core_attr const ::CORBA::WChar * isDummyServer;

    static _core_attr const ::CORBA::WChar * searchPath;

  
  };

  class _objref_Properties :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::WChar* getProperty(const ::CORBA::WChar* propertyName);
    WStrings* getPropertyList();

    inline _objref_Properties()  { _PR_setobj(0); }  // nil
    _objref_Properties(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Properties();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Properties(const _objref_Properties&);
    _objref_Properties& operator = (const _objref_Properties&);
    // not implemented

    friend class Properties;
  };

  class _pof_Properties : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Properties() : _OMNI_NS(proxyObjectFactory)(Properties::_PD_repoId) {}
    virtual ~_pof_Properties();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Properties :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Properties();

    virtual ::CORBA::WChar* getProperty(const ::CORBA::WChar* propertyName) = 0;
    virtual WStrings* getPropertyList() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __Quentin_mEffectController__
#define __Quentin_mEffectController__

  class EffectController;
  class _objref_EffectController;
  class _impl_EffectController;
  
  typedef _objref_EffectController* EffectController_ptr;
  typedef EffectController_ptr EffectControllerRef;

  class EffectController_Helper {
  public:
    typedef EffectController_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EffectController, EffectController_Helper> EffectController_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EffectController,EffectController_Helper > EffectController_out;

#endif

  // interface EffectController
  class EffectController {
  public:
    // Declarations for this interface type.
    typedef EffectController_ptr _ptr_type;
    typedef EffectController_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_EffectController :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::WChar* getName();
    ::CORBA::Long getVersion();
    void reset();
    RawData* getState();
    void setState(const ::Quentin::RawData& state);

    inline _objref_EffectController()  { _PR_setobj(0); }  // nil
    _objref_EffectController(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EffectController();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EffectController(const _objref_EffectController&);
    _objref_EffectController& operator = (const _objref_EffectController&);
    // not implemented

    friend class EffectController;
  };

  class _pof_EffectController : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EffectController() : _OMNI_NS(proxyObjectFactory)(EffectController::_PD_repoId) {}
    virtual ~_pof_EffectController();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EffectController :
    public virtual omniServant
  {
  public:
    virtual ~_impl_EffectController();

    virtual ::CORBA::WChar* getName() = 0;
    virtual ::CORBA::Long getVersion() = 0;
    virtual void reset() = 0;
    virtual RawData* getState() = 0;
    virtual void setState(const ::Quentin::RawData& state) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  enum ChannelType { halfDuplex, fullDuplex, simplexRecord, simplexPlayback /*, __max_ChannelType=0xffffffff */ };
  typedef ChannelType& ChannelType_out;

  struct ChannelCapabilities {
    typedef _CORBA_ConstrType_Fix_Var<ChannelCapabilities> _var_type;

    
    ::CORBA::Long chanNumber;

    ChannelType type;

    ::CORBA::Long inputCount;

    ::CORBA::Long outputCount;

    ::CORBA::LongLong generalFeatures;

    ::CORBA::LongLong recordFeatures;

    ::CORBA::LongLong playFeatures;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ChannelCapabilities::_var_type ChannelCapabilities_var;

  typedef ChannelCapabilities& ChannelCapabilities_out;

  _CORBA_MODULE_VARINT const ::CORBA::LongLong CHANCAP_GEN_OVERLAY _init_in_decl_( = _CORBA_LONGLONG_CONST(1) );

  _CORBA_MODULE_VARINT const ::CORBA::LongLong CHANCAP_REC_AUTOSIZE _init_in_decl_( = _CORBA_LONGLONG_CONST(1) );

  _CORBA_MODULE_VARINT const ::CORBA::LongLong CHANCAP_REC_AIR _init_in_decl_( = _CORBA_LONGLONG_CONST(2) );

  _CORBA_MODULE_VARINT const ::CORBA::LongLong CHANCAP_PLAY_SUBFRAME_JOG _init_in_decl_( = _CORBA_LONGLONG_CONST(1) );

  _CORBA_MODULE_VARINT const ::CORBA::LongLong CHANCAP_PLAY_LIVE_CLAMP _init_in_decl_( = _CORBA_LONGLONG_CONST(2) );

  _CORBA_MODULE_VARINT const ::CORBA::LongLong CHANCAP_PLAY_AUDIO_16CH _init_in_decl_( = _CORBA_LONGLONG_CONST(256) );

  _CORBA_MODULE_VARINT const ::CORBA::LongLong CHANCAP_PLAY_AUDIO_32CH _init_in_decl_( = _CORBA_LONGLONG_CONST(512) );

  class ChannelCapabilitiesList_var;

  class ChannelCapabilitiesList : public _CORBA_Unbounded_Sequence< ChannelCapabilities >  {
  public:
    typedef ChannelCapabilitiesList_var _var_type;
    inline ChannelCapabilitiesList() {}
    inline ChannelCapabilitiesList(const ChannelCapabilitiesList& _s)
      : _CORBA_Unbounded_Sequence< ChannelCapabilities > (_s) {}

    inline ChannelCapabilitiesList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ChannelCapabilities > (_max) {}
    inline ChannelCapabilitiesList(_CORBA_ULong _max, _CORBA_ULong _len, ChannelCapabilities* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ChannelCapabilities > (_max, _len, _val, _rel) {}

  

    inline ChannelCapabilitiesList& operator = (const ChannelCapabilitiesList& _s) {
      _CORBA_Unbounded_Sequence< ChannelCapabilities > ::operator=(_s);
      return *this;
    }
  };

  class ChannelCapabilitiesList_out;

  class ChannelCapabilitiesList_var {
  public:
    inline ChannelCapabilitiesList_var() : _pd_seq(0) {}
    inline ChannelCapabilitiesList_var(ChannelCapabilitiesList* _s) : _pd_seq(_s) {}
    inline ChannelCapabilitiesList_var(const ChannelCapabilitiesList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ChannelCapabilitiesList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ChannelCapabilitiesList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ChannelCapabilitiesList_var& operator = (ChannelCapabilitiesList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ChannelCapabilitiesList_var& operator = (const ChannelCapabilitiesList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ChannelCapabilitiesList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ChannelCapabilities& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ChannelCapabilitiesList* operator -> () { return _pd_seq; }
    inline const ChannelCapabilitiesList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ChannelCapabilitiesList& () const { return *_pd_seq; }
#else
    inline operator const ChannelCapabilitiesList& () const { return *_pd_seq; }
    inline operator ChannelCapabilitiesList& () { return *_pd_seq; }
#endif
      
    inline const ChannelCapabilitiesList& in() const { return *_pd_seq; }
    inline ChannelCapabilitiesList&       inout()    { return *_pd_seq; }
    inline ChannelCapabilitiesList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ChannelCapabilitiesList* _retn() { ChannelCapabilitiesList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ChannelCapabilitiesList_out;
    
  private:
    ChannelCapabilitiesList* _pd_seq;
  };

  class ChannelCapabilitiesList_out {
  public:
    inline ChannelCapabilitiesList_out(ChannelCapabilitiesList*& _s) : _data(_s) { _data = 0; }
    inline ChannelCapabilitiesList_out(ChannelCapabilitiesList_var& _s)
      : _data(_s._pd_seq) { _s = (ChannelCapabilitiesList*) 0; }
    inline ChannelCapabilitiesList_out(const ChannelCapabilitiesList_out& _s) : _data(_s._data) {}
    inline ChannelCapabilitiesList_out& operator = (const ChannelCapabilitiesList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ChannelCapabilitiesList_out& operator = (ChannelCapabilitiesList* _s) {
      _data = _s;
      return *this;
    }
    inline operator ChannelCapabilitiesList*&()  { return _data; }
    inline ChannelCapabilitiesList*& ptr()       { return _data; }
    inline ChannelCapabilitiesList* operator->() { return _data; }

    inline ChannelCapabilities& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ChannelCapabilitiesList*& _data;

  private:
    ChannelCapabilitiesList_out();
    ChannelCapabilitiesList_out& operator=(const ChannelCapabilitiesList_var&);
  };

  struct ServerCapabilities {
    typedef _CORBA_ConstrType_Variable_Var<ServerCapabilities> _var_type;

    
    ::CORBA::Long productID;

    ::CORBA::LongLong features;

    ChannelCapabilitiesList channelCapabilities;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ServerCapabilities::_var_type ServerCapabilities_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ServerCapabilities,ServerCapabilities_var > ServerCapabilities_out;

  _CORBA_MODULE_VARINT const ::CORBA::LongLong SVRCAP_REMOTE_PRELOAD_SQ _init_in_decl_( = _CORBA_LONGLONG_CONST(1) );

  _CORBA_MODULE_VARINT const ::CORBA::LongLong SVRCAP_REMOTE_PRELOAD_REVQ _init_in_decl_( = _CORBA_LONGLONG_CONST(2) );

  struct AudioPatchInfo {
    typedef _CORBA_ConstrType_Fix_Var<AudioPatchInfo> _var_type;

    
    ::CORBA::Long dst;

    ::CORBA::Long src;

    ::CORBA::Float level;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef AudioPatchInfo::_var_type AudioPatchInfo_var;

  typedef AudioPatchInfo& AudioPatchInfo_out;

  class AudioPatchInfoList_var;

  class AudioPatchInfoList : public _CORBA_Unbounded_Sequence< AudioPatchInfo >  {
  public:
    typedef AudioPatchInfoList_var _var_type;
    inline AudioPatchInfoList() {}
    inline AudioPatchInfoList(const AudioPatchInfoList& _s)
      : _CORBA_Unbounded_Sequence< AudioPatchInfo > (_s) {}

    inline AudioPatchInfoList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< AudioPatchInfo > (_max) {}
    inline AudioPatchInfoList(_CORBA_ULong _max, _CORBA_ULong _len, AudioPatchInfo* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< AudioPatchInfo > (_max, _len, _val, _rel) {}

  

    inline AudioPatchInfoList& operator = (const AudioPatchInfoList& _s) {
      _CORBA_Unbounded_Sequence< AudioPatchInfo > ::operator=(_s);
      return *this;
    }
  };

  class AudioPatchInfoList_out;

  class AudioPatchInfoList_var {
  public:
    inline AudioPatchInfoList_var() : _pd_seq(0) {}
    inline AudioPatchInfoList_var(AudioPatchInfoList* _s) : _pd_seq(_s) {}
    inline AudioPatchInfoList_var(const AudioPatchInfoList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new AudioPatchInfoList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~AudioPatchInfoList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline AudioPatchInfoList_var& operator = (AudioPatchInfoList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline AudioPatchInfoList_var& operator = (const AudioPatchInfoList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new AudioPatchInfoList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline AudioPatchInfo& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline AudioPatchInfoList* operator -> () { return _pd_seq; }
    inline const AudioPatchInfoList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator AudioPatchInfoList& () const { return *_pd_seq; }
#else
    inline operator const AudioPatchInfoList& () const { return *_pd_seq; }
    inline operator AudioPatchInfoList& () { return *_pd_seq; }
#endif
      
    inline const AudioPatchInfoList& in() const { return *_pd_seq; }
    inline AudioPatchInfoList&       inout()    { return *_pd_seq; }
    inline AudioPatchInfoList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline AudioPatchInfoList* _retn() { AudioPatchInfoList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class AudioPatchInfoList_out;
    
  private:
    AudioPatchInfoList* _pd_seq;
  };

  class AudioPatchInfoList_out {
  public:
    inline AudioPatchInfoList_out(AudioPatchInfoList*& _s) : _data(_s) { _data = 0; }
    inline AudioPatchInfoList_out(AudioPatchInfoList_var& _s)
      : _data(_s._pd_seq) { _s = (AudioPatchInfoList*) 0; }
    inline AudioPatchInfoList_out(const AudioPatchInfoList_out& _s) : _data(_s._data) {}
    inline AudioPatchInfoList_out& operator = (const AudioPatchInfoList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline AudioPatchInfoList_out& operator = (AudioPatchInfoList* _s) {
      _data = _s;
      return *this;
    }
    inline operator AudioPatchInfoList*&()  { return _data; }
    inline AudioPatchInfoList*& ptr()       { return _data; }
    inline AudioPatchInfoList* operator->() { return _data; }

    inline AudioPatchInfo& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    AudioPatchInfoList*& _data;

  private:
    AudioPatchInfoList_out();
    AudioPatchInfoList_out& operator=(const AudioPatchInfoList_var&);
  };

  class InvalidFragments : public ::CORBA::UserException {
  public:
    
    ServerFragments invalids;

  

    inline InvalidFragments() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidFragments(const InvalidFragments&);
    InvalidFragments(const ServerFragments i_invalids);
    InvalidFragments& operator=(const InvalidFragments&);
    virtual ~InvalidFragments();
    virtual void _raise() const;
    static InvalidFragments* _downcast(::CORBA::Exception*);
    static const InvalidFragments* _downcast(const ::CORBA::Exception*);
    static inline InvalidFragments* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  class DatabaseError : public ::CORBA::UserException {
  public:
    
    ::CORBA::WString_member error;

  

    inline DatabaseError() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    DatabaseError(const DatabaseError&);
    DatabaseError(const ::CORBA::WChar* i_error);
    DatabaseError& operator=(const DatabaseError&);
    virtual ~DatabaseError();
    virtual void _raise() const;
    static DatabaseError* _downcast(::CORBA::Exception*);
    static const DatabaseError* _downcast(const ::CORBA::Exception*);
    static inline DatabaseError* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  enum BadIdentReason { internalError, poolNotKnown, poolNotOnThisServer, poolNotAvailable, serverNotKnown, clipNotKnown, channelNotKnown, formatNotKnown, rowNotKnown, serverIsDown, badFragment, triggerNotKnown, invalidMode, badTicket, configNotKnown, zoneNotKnown, notPlaceholder, badLoggingRole, operationNotSupported /*, __max_BadIdentReason=0xffffffff */ };
  typedef BadIdentReason& BadIdentReason_out;

  class BadIdent : public ::CORBA::UserException {
  public:
    
    BadIdentReason reason;

    ::CORBA::Long ident;

  

    inline BadIdent() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    BadIdent(const BadIdent&);
    BadIdent(BadIdentReason i_reason, ::CORBA::Long i_ident);
    BadIdent& operator=(const BadIdent&);
    virtual ~BadIdent();
    virtual void _raise() const;
    static BadIdent* _downcast(::CORBA::Exception*);
    static const BadIdent* _downcast(const ::CORBA::Exception*);
    static inline BadIdent* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  class BadColumnData : public ::CORBA::UserException {
  public:
    
    ::CORBA::WString_member colName;

    ::CORBA::WString_member badData;

  

    inline BadColumnData() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    BadColumnData(const BadColumnData&);
    BadColumnData(const ::CORBA::WChar* i_colName, const ::CORBA::WChar* i_badData);
    BadColumnData& operator=(const BadColumnData&);
    virtual ~BadColumnData();
    virtual void _raise() const;
    static BadColumnData* _downcast(::CORBA::Exception*);
    static const BadColumnData* _downcast(const ::CORBA::Exception*);
    static inline BadColumnData* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  class NoSpace : public ::CORBA::UserException {
  public:
    
    

    inline NoSpace() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    NoSpace(const NoSpace&);
    
    NoSpace& operator=(const NoSpace&);
    virtual ~NoSpace();
    virtual void _raise() const;
    static NoSpace* _downcast(::CORBA::Exception*);
    static const NoSpace* _downcast(const ::CORBA::Exception*);
    static inline NoSpace* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  class WrongMode : public ::CORBA::UserException {
  public:
    
    

    inline WrongMode() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    WrongMode(const WrongMode&);
    
    WrongMode& operator=(const WrongMode&);
    virtual ~WrongMode();
    virtual void _raise() const;
    static WrongMode* _downcast(::CORBA::Exception*);
    static const WrongMode* _downcast(const ::CORBA::Exception*);
    static inline WrongMode* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  class ZoneInaccessable : public ::CORBA::UserException {
  public:
    
    

    inline ZoneInaccessable() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    ZoneInaccessable(const ZoneInaccessable&);
    
    ZoneInaccessable& operator=(const ZoneInaccessable&);
    virtual ~ZoneInaccessable();
    virtual void _raise() const;
    static ZoneInaccessable* _downcast(::CORBA::Exception*);
    static const ZoneInaccessable* _downcast(const ::CORBA::Exception*);
    static inline ZoneInaccessable* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

#ifndef __Quentin_mThumbnailListener__
#define __Quentin_mThumbnailListener__

  class ThumbnailListener;
  class _objref_ThumbnailListener;
  class _impl_ThumbnailListener;
  
  typedef _objref_ThumbnailListener* ThumbnailListener_ptr;
  typedef ThumbnailListener_ptr ThumbnailListenerRef;

  class ThumbnailListener_Helper {
  public:
    typedef ThumbnailListener_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ThumbnailListener, ThumbnailListener_Helper> ThumbnailListener_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ThumbnailListener,ThumbnailListener_Helper > ThumbnailListener_out;

#endif

  // interface ThumbnailListener
  class ThumbnailListener {
  public:
    // Declarations for this interface type.
    typedef ThumbnailListener_ptr _ptr_type;
    typedef ThumbnailListener_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    enum NoThumbnailReason { unknown, unrecorded, unbuilt, busy, badFormat, hardwareError /*, __max_NoThumbnailReason=0xffffffff */ };
    typedef NoThumbnailReason& NoThumbnailReason_out;

  
  };

  class _objref_ThumbnailListener :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void newThumbnail(::CORBA::Long ident, ::CORBA::Long offset, ::CORBA::Long width, ::CORBA::Long height, const ::Quentin::Longs& data);
    void noThumbnail(::Quentin::ThumbnailListener::NoThumbnailReason reason, ::CORBA::Long ident, ::CORBA::Long offset, ::CORBA::Boolean tryAgainLater, const ::CORBA::WChar* reasonStr);
    void finished(::CORBA::Long ident);

    inline _objref_ThumbnailListener()  { _PR_setobj(0); }  // nil
    _objref_ThumbnailListener(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ThumbnailListener();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ThumbnailListener(const _objref_ThumbnailListener&);
    _objref_ThumbnailListener& operator = (const _objref_ThumbnailListener&);
    // not implemented

    friend class ThumbnailListener;
  };

  class _pof_ThumbnailListener : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ThumbnailListener() : _OMNI_NS(proxyObjectFactory)(ThumbnailListener::_PD_repoId) {}
    virtual ~_pof_ThumbnailListener();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ThumbnailListener :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ThumbnailListener();

    virtual void newThumbnail(::CORBA::Long ident, ::CORBA::Long offset, ::CORBA::Long width, ::CORBA::Long height, const ::Quentin::Longs& data) = 0;
    virtual void noThumbnail(::Quentin::ThumbnailListener::NoThumbnailReason reason, ::CORBA::Long ident, ::CORBA::Long offset, ::CORBA::Boolean tryAgainLater, const ::CORBA::WChar* reasonStr) = 0;
    virtual void finished(::CORBA::Long ident) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __Quentin_mPortListener__
#define __Quentin_mPortListener__

  class PortListener;
  class _objref_PortListener;
  class _impl_PortListener;
  
  typedef _objref_PortListener* PortListener_ptr;
  typedef PortListener_ptr PortListenerRef;

  class PortListener_Helper {
  public:
    typedef PortListener_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PortListener, PortListener_Helper> PortListener_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PortListener,PortListener_Helper > PortListener_out;

#endif

  // interface PortListener
  class PortListener {
  public:
    // Declarations for this interface type.
    typedef PortListener_ptr _ptr_type;
    typedef PortListener_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _core_attr const ::CORBA::Long listenerPresent _init_in_cldecl_( = 32768 );

    struct PlayPortStatus {
      typedef _CORBA_ConstrType_Fix_Var<PlayPortStatus> _var_type;

      
      ::CORBA::Long portNumber;

      ::CORBA::ULong flags;

      Timecode refTime;

      Timecode portTime;

      ::CORBA::Long framesUnused;

      ::CORBA::Long offset;

      ::CORBA::Long endOfData;

      ::CORBA::Float speed;

      Timecode outputTime;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef PlayPortStatus::_var_type PlayPortStatus_var;

    typedef PlayPortStatus& PlayPortStatus_out;

    static _core_attr const ::CORBA::Long readyToPlay _init_in_cldecl_( = 1 );

    static _core_attr const ::CORBA::Long playing _init_in_cldecl_( = 2 );

    static _core_attr const ::CORBA::Long jumpReady _init_in_cldecl_( = 4 );

    static _core_attr const ::CORBA::Long fading _init_in_cldecl_( = 8 );

    static _core_attr const ::CORBA::Long opAudioFlagsMask _init_in_cldecl_( = 3840 );

    static _core_attr const ::CORBA::Long opAudioGrp1 _init_in_cldecl_( = 256 );

    static _core_attr const ::CORBA::Long opAudioGrp2 _init_in_cldecl_( = 512 );

    static _core_attr const ::CORBA::Long opStdFlagsMask _init_in_cldecl_( = 15728640 );

    static _core_attr const ::CORBA::Long opStdSD _init_in_cldecl_( = 0 );

    static _core_attr const ::CORBA::Long opStdSD4_3 _init_in_cldecl_( = 1048576 );

    static _core_attr const ::CORBA::Long opStdSD16_9 _init_in_cldecl_( = 2097152 );

    static _core_attr const ::CORBA::Long opStdHD720p _init_in_cldecl_( = 3145728 );

    static _core_attr const ::CORBA::Long opStdHD1080i _init_in_cldecl_( = 4194304 );

    static _core_attr const ::CORBA::Long opStdHD1080p _init_in_cldecl_( = 5242880 );

    static _core_attr const ::CORBA::Long fieldMode _init_in_cldecl_( = 65536 );

    static _core_attr const ::CORBA::Long fieldAuto _init_in_cldecl_( = 131072 );

    static _core_attr const ::CORBA::Long fieldNonDom _init_in_cldecl_( = 262144 );

    struct RecordPortStatus {
      typedef _CORBA_ConstrType_Fix_Var<RecordPortStatus> _var_type;

      
      ::CORBA::Long portNumber;

      ::CORBA::ULong flags;

      Timecode refTime;

      Timecode portTime;

      ::CORBA::Long offset;

      ::CORBA::Long framesUnused;

      ::CORBA::Long start;

      ::CORBA::Long finish;

      ::CORBA::Long recordableFrames;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef RecordPortStatus::_var_type RecordPortStatus_var;

    typedef RecordPortStatus& RecordPortStatus_out;

    static _core_attr const ::CORBA::Long readyToRecord _init_in_cldecl_( = 1 );

    static _core_attr const ::CORBA::Long recording _init_in_cldecl_( = 2 );

    static _core_attr const ::CORBA::Long overWriting _init_in_cldecl_( = 8 );

    static _core_attr const ::CORBA::Long inputInvalid _init_in_cldecl_( = 16 );

    static _core_attr const ::CORBA::Long nonStop _init_in_cldecl_( = 65536 );

    static _core_attr const ::CORBA::Long ipAudioFlagsMask _init_in_cldecl_( = 3840 );

    static _core_attr const ::CORBA::Long ipAudioGrp1 _init_in_cldecl_( = 256 );

    static _core_attr const ::CORBA::Long ipAudioGrp2 _init_in_cldecl_( = 512 );

    static _core_attr const ::CORBA::Long ipStdMask _init_in_cldecl_( = 15728640 );

    static _core_attr const ::CORBA::Long ipStdSD _init_in_cldecl_( = 0 );

    static _core_attr const ::CORBA::Long ipStdSD4_3 _init_in_cldecl_( = 1048576 );

    static _core_attr const ::CORBA::Long ipStdSD16_9 _init_in_cldecl_( = 2097152 );

    static _core_attr const ::CORBA::Long ipStdHD720p _init_in_cldecl_( = 3145728 );

    static _core_attr const ::CORBA::Long ipStdHD1080i _init_in_cldecl_( = 4194304 );

    static _core_attr const ::CORBA::Long ipStdHD1080p _init_in_cldecl_( = 5242880 );

    struct IdlePortStatus {
      typedef _CORBA_ConstrType_Fix_Var<IdlePortStatus> _var_type;

      
      ::CORBA::Long portNumber;

      ::CORBA::ULong flags;

      Timecode refTime;

      Timecode portTime;

      ::CORBA::Long framesUnused;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef IdlePortStatus::_var_type IdlePortStatus_var;

    typedef IdlePortStatus& IdlePortStatus_out;

    static _core_attr const ::CORBA::Long idleAudioFlagsMask _init_in_cldecl_( = 3840 );

    static _core_attr const ::CORBA::Long idleAudioGrp1 _init_in_cldecl_( = 256 );

    static _core_attr const ::CORBA::Long idleAudioGrp2 _init_in_cldecl_( = 512 );

    static _core_attr const ::CORBA::Long idleStdMask _init_in_cldecl_( = 15728640 );

    static _core_attr const ::CORBA::Long idleStdSD _init_in_cldecl_( = 0 );

    static _core_attr const ::CORBA::Long idleStdSD4_3 _init_in_cldecl_( = 1048576 );

    static _core_attr const ::CORBA::Long idleStdSD16_9 _init_in_cldecl_( = 2097152 );

    static _core_attr const ::CORBA::Long idleStdHD720p _init_in_cldecl_( = 3145728 );

    static _core_attr const ::CORBA::Long idleStdHD1080i _init_in_cldecl_( = 4194304 );

    static _core_attr const ::CORBA::Long idleStdHD1080p _init_in_cldecl_( = 5242880 );

    struct NoteEvent {
      typedef _CORBA_ConstrType_Variable_Var<NoteEvent> _var_type;

      
      ::CORBA::Long portNumber;

      ::CORBA::Long trackNum;

      ::CORBA::Long offset;

      ::CORBA::Long noteTime;

      ::CORBA::Long eventID;

      ::CORBA::Long aux;

      ::CORBA::WString_member note;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef NoteEvent::_var_type NoteEvent_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< NoteEvent,NoteEvent_var > NoteEvent_out;

  
  };

  class _objref_PortListener :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void newPlayStatus(const ::Quentin::PortListener::PlayPortStatus& status);
    void newRecordStatus(const ::Quentin::PortListener::RecordPortStatus& status);
    void newIdleStatus(const ::Quentin::PortListener::IdlePortStatus& status);
    void reportNote(const ::Quentin::PortListener::NoteEvent& note);

    inline _objref_PortListener()  { _PR_setobj(0); }  // nil
    _objref_PortListener(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PortListener();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PortListener(const _objref_PortListener&);
    _objref_PortListener& operator = (const _objref_PortListener&);
    // not implemented

    friend class PortListener;
  };

  class _pof_PortListener : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PortListener() : _OMNI_NS(proxyObjectFactory)(PortListener::_PD_repoId) {}
    virtual ~_pof_PortListener();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PortListener :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PortListener();

    virtual void newPlayStatus(const ::Quentin::PortListener::PlayPortStatus& status) = 0;
    virtual void newRecordStatus(const ::Quentin::PortListener::RecordPortStatus& status) = 0;
    virtual void newIdleStatus(const ::Quentin::PortListener::IdlePortStatus& status) = 0;
    virtual void reportNote(const ::Quentin::PortListener::NoteEvent& note) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __Quentin_mStateChangeListener__
#define __Quentin_mStateChangeListener__

  class StateChangeListener;
  class _objref_StateChangeListener;
  class _impl_StateChangeListener;
  
  typedef _objref_StateChangeListener* StateChangeListener_ptr;
  typedef StateChangeListener_ptr StateChangeListenerRef;

  class StateChangeListener_Helper {
  public:
    typedef StateChangeListener_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_StateChangeListener, StateChangeListener_Helper> StateChangeListener_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_StateChangeListener,StateChangeListener_Helper > StateChangeListener_out;

#endif

  // interface StateChangeListener
  class StateChangeListener {
  public:
    // Declarations for this interface type.
    typedef StateChangeListener_ptr _ptr_type;
    typedef StateChangeListener_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _core_attr const ::CORBA::Long clipChanges _init_in_cldecl_( = 1 );

    static _core_attr const ::CORBA::Long serverChanges _init_in_cldecl_( = 2 );

    static _core_attr const ::CORBA::Long poolChanges _init_in_cldecl_( = 4 );

    static _core_attr const ::CORBA::Long listenerChanges _init_in_cldecl_( = 8 );

    static _core_attr const ::CORBA::Long copyCompletions _init_in_cldecl_( = 16 );

    static _core_attr const ::CORBA::Long zoneChanges _init_in_cldecl_( = 32 );

  
  };

  class _objref_StateChangeListener :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void newChanges(const ::Quentin::StateChangeList& list);

    inline _objref_StateChangeListener()  { _PR_setobj(0); }  // nil
    _objref_StateChangeListener(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_StateChangeListener();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_StateChangeListener(const _objref_StateChangeListener&);
    _objref_StateChangeListener& operator = (const _objref_StateChangeListener&);
    // not implemented

    friend class StateChangeListener;
  };

  class _pof_StateChangeListener : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_StateChangeListener() : _OMNI_NS(proxyObjectFactory)(StateChangeListener::_PD_repoId) {}
    virtual ~_pof_StateChangeListener();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_StateChangeListener :
    public virtual omniServant
  {
  public:
    virtual ~_impl_StateChangeListener();

    virtual void newChanges(const ::Quentin::StateChangeList& list) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __Quentin_mPort__
#define __Quentin_mPort__

  class Port;
  class _objref_Port;
  class _impl_Port;
  
  typedef _objref_Port* Port_ptr;
  typedef Port_ptr PortRef;

  class Port_Helper {
  public:
    typedef Port_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Port, Port_Helper> Port_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Port,Port_Helper > Port_out;

#endif

  // interface Port
  class Port {
  public:
    // Declarations for this interface type.
    typedef Port_ptr _ptr_type;
    typedef Port_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _core_attr const ::CORBA::Long LowPriority _init_in_cldecl_( = 0 );

    static _core_attr const ::CORBA::Long StandardPriority _init_in_cldecl_( = 8 );

    static _core_attr const ::CORBA::Long HighPriority _init_in_cldecl_( = 15 );

    static _core_attr const ::CORBA::Long invalidTimecode _init_in_cldecl_( = -1 );

    static _core_attr const ::CORBA::Long dropFrameFlag _init_in_cldecl_( = 1073741824 );

    static _core_attr const ::CORBA::Long crashFlag _init_in_cldecl_( = 128 );

    static _core_attr const ::CORBA::Long numTriggers _init_in_cldecl_( = 32 );

    enum TriggerMode { trModeNever, trModeNow, trModeOffset, trModeRefTimecode, trModePortTimecode, trNumModes /*, __max_TriggerMode=0xffffffff */ };
    typedef TriggerMode& TriggerMode_out;

    enum TriggerAction { trActNothing, trActStart, trActStop, trActJump, trActTransition, trNumActions /*, __max_TriggerAction=0xffffffff */ };
    typedef TriggerAction& TriggerAction_out;

    enum PortMode { idle, recording, playing /*, __max_PortMode=0xffffffff */ };
    typedef PortMode& PortMode_out;

    class GeneralPortStatus {
    public:

      typedef _CORBA_ConstrType_Fix_Var<GeneralPortStatus> _var_type;

      

      GeneralPortStatus(): _pd__initialised(0) {
        
      }
      
      GeneralPortStatus(const GeneralPortStatus& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case idle: idleStatus(_value._pd_idleStatus); break;

          case recording: recStatus(_value._pd_recStatus); break;

          case playing: playStatus(_value._pd_playStatus); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
      }

      ~GeneralPortStatus() {}

      GeneralPortStatus& operator=(const GeneralPortStatus& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case idle: idleStatus(_value._pd_idleStatus); break;

          case recording: recStatus(_value._pd_recStatus); break;

          case playing: playStatus(_value._pd_playStatus); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
        return *this;
      }

      PortMode _d() const { return _pd__d;}
      void _d(PortMode _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case idle: goto fail;
          case recording: goto fail;
          case playing: goto fail;
          default: goto fail;

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      

      const PortListener::IdlePortStatus &idleStatus () const { return _pd_idleStatus; }
      PortListener::IdlePortStatus &idleStatus () { return _pd_idleStatus; }
      void idleStatus (const PortListener::IdlePortStatus& _value) {
        _pd__initialised = 1;
        _pd__d = idle;
        _pd__default = 0;
        _pd_idleStatus = _value;
      }

      const PortListener::RecordPortStatus &recStatus () const { return _pd_recStatus; }
      PortListener::RecordPortStatus &recStatus () { return _pd_recStatus; }
      void recStatus (const PortListener::RecordPortStatus& _value) {
        _pd__initialised = 1;
        _pd__d = recording;
        _pd__default = 0;
        _pd_recStatus = _value;
      }

      const PortListener::PlayPortStatus &playStatus () const { return _pd_playStatus; }
      PortListener::PlayPortStatus &playStatus () { return _pd_playStatus; }
      void playStatus (const PortListener::PlayPortStatus& _value) {
        _pd__initialised = 1;
        _pd__d = playing;
        _pd__default = 0;
        _pd_playStatus = _value;
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      PortMode _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      
      PortListener::IdlePortStatus _pd_idleStatus;

      PortListener::RecordPortStatus _pd_recStatus;

      PortListener::PlayPortStatus _pd_playStatus;

    
    };

    typedef GeneralPortStatus::_var_type GeneralPortStatus_var;

    typedef GeneralPortStatus& GeneralPortStatus_out;

    struct TriggerState {
      typedef _CORBA_ConstrType_Fix_Var<TriggerState> _var_type;

      
      TriggerAction action;

      TriggerMode mode;

      ::CORBA::Long param;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TriggerState::_var_type TriggerState_var;

    typedef TriggerState& TriggerState_out;

    class TriggerStates_var;

    class TriggerStates : public _CORBA_Unbounded_Sequence< TriggerState >  {
    public:
      typedef TriggerStates_var _var_type;
      inline TriggerStates() {}
      inline TriggerStates(const TriggerStates& _s)
        : _CORBA_Unbounded_Sequence< TriggerState > (_s) {}

      inline TriggerStates(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TriggerState > (_max) {}
      inline TriggerStates(_CORBA_ULong _max, _CORBA_ULong _len, TriggerState* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TriggerState > (_max, _len, _val, _rel) {}

    

      inline TriggerStates& operator = (const TriggerStates& _s) {
        _CORBA_Unbounded_Sequence< TriggerState > ::operator=(_s);
        return *this;
      }
    };

    class TriggerStates_out;

    class TriggerStates_var {
    public:
      inline TriggerStates_var() : _pd_seq(0) {}
      inline TriggerStates_var(TriggerStates* _s) : _pd_seq(_s) {}
      inline TriggerStates_var(const TriggerStates_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TriggerStates(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TriggerStates_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TriggerStates_var& operator = (TriggerStates* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TriggerStates_var& operator = (const TriggerStates_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TriggerStates;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TriggerState& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TriggerStates* operator -> () { return _pd_seq; }
      inline const TriggerStates* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TriggerStates& () const { return *_pd_seq; }
#else
      inline operator const TriggerStates& () const { return *_pd_seq; }
      inline operator TriggerStates& () { return *_pd_seq; }
#endif
        
      inline const TriggerStates& in() const { return *_pd_seq; }
      inline TriggerStates&       inout()    { return *_pd_seq; }
      inline TriggerStates*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TriggerStates* _retn() { TriggerStates* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TriggerStates_out;
      
    private:
      TriggerStates* _pd_seq;
    };

    class TriggerStates_out {
    public:
      inline TriggerStates_out(TriggerStates*& _s) : _data(_s) { _data = 0; }
      inline TriggerStates_out(TriggerStates_var& _s)
        : _data(_s._pd_seq) { _s = (TriggerStates*) 0; }
      inline TriggerStates_out(const TriggerStates_out& _s) : _data(_s._data) {}
      inline TriggerStates_out& operator = (const TriggerStates_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TriggerStates_out& operator = (TriggerStates* _s) {
        _data = _s;
        return *this;
      }
      inline operator TriggerStates*&()  { return _data; }
      inline TriggerStates*& ptr()       { return _data; }
      inline TriggerStates* operator->() { return _data; }

      inline TriggerState& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TriggerStates*& _data;

    private:
      TriggerStates_out();
      TriggerStates_out& operator=(const TriggerStates_var&);
    };

    static _core_attr const ::CORBA::ULong userFlagsMask _init_in_cldecl_( = 2147418112U );

    static _core_attr const ::CORBA::Long alertRed _init_in_cldecl_( = 32768 );

    static _core_attr const ::CORBA::Long alertAmber _init_in_cldecl_( = 16384 );

    static _core_attr const ::CORBA::Long audioOnly _init_in_cldecl_( = 1 );

    enum TransitionType { crossFadeWithAudioMix /*, __max_TransitionType=0xffffffff */ };
    typedef TransitionType& TransitionType_out;

    enum OverlayTextColour { olColourWhite, olColourBlack, olColourRed, olColourGreen, olColourBlue, olColourCyan, olColourYellow, olColourMagenta /*, __max_OverlayTextColour=0xffffffff */ };
    typedef OverlayTextColour& OverlayTextColour_out;

    static _core_attr const ::CORBA::WChar * OI_Tally;

  
  };

  class _objref_Port :
    public virtual _objref_Properties
  {
  public:
    void changeFlags(::CORBA::Long mask, ::CORBA::Long newFlags);
    ::CORBA::Boolean setMode(::Quentin::Port::PortMode newMode);
    void reset();
    void resetTriggers();
    void resetTracks();
    void setTrackLimits(::CORBA::Long startFrame, ::CORBA::Long endFrame);
    Port::GeneralPortStatus getStatus();
    void reportStatus(::Quentin::PortListener_ptr listener, ::CORBA::Long interval, ::CORBA::Long noteMask);
    ::CORBA::Boolean setTrigger(::CORBA::Long trigger, ::Quentin::Port::TriggerMode mode, ::CORBA::Long param);
    ::CORBA::Boolean actionAtTrigger(::CORBA::Long trigger, ::Quentin::Port::TriggerAction action);
    Port::TriggerState getTrigger(::CORBA::Long trigger);
    Port::TriggerStates* getTriggers();
    ServerFragments* getPortFragments(::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getPortTypeFragments(::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long fragType);
    ServerFragments* getPortTrackFragments(::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long fragType, ::CORBA::Long trackNum);
    void getThumbnailSize(::CORBA::Long mode, ::CORBA::Long& width, ::CORBA::Long& height);
    void setThumbnailListener(::CORBA::Long mode, ::CORBA::Long chanNum, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener, ::CORBA::Long minInterval);
    ::CORBA::Long requestThumbnails(::CORBA::Long mode, ::CORBA::Long chanNum, ::CORBA::Long offset, ::CORBA::Long stride, ::CORBA::Long count, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener);
    void abortThumbnails(::CORBA::Long abortID);
    WStrings* controllerNames();
    EffectController_ptr getController(::CORBA::Long trackNum);
    PortInfo* getPortInfo();
    DirectoryViewer_ptr getDirViewer(::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName);
    DirectoryViewer_ptr getPoolDirViewer(::CORBA::Long poolID, ::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName);
    ConfigDescriptionList* getConfigurations(::CORBA::Long channel, ::Quentin::FragmentType type, ::CORBA::Boolean forPlay);
    Longs* getDefaultConfigurations(::CORBA::Long channel);
    Longs* getCurrentConfigurations(::CORBA::Long channel);
    void configure(::CORBA::Long channel, const ::Quentin::Longs& configurations);
    ::CORBA::Boolean assignChannel(::CORBA::Long chanNum, ::CORBA::Long flags);
    void assignTransitionPort(::Quentin::Port_ptr transitionPort);
    Port_ptr getTransitionPort();
    Longs* getChannels();
    void release();
    void load(::CORBA::Long offset, const ::Quentin::ServerFragments& fragments);
    void insertBlank(::CORBA::Long start, ::CORBA::Long frames);
    ::CORBA::Boolean remove(::CORBA::Long start, ::CORBA::Long frames);
    ::CORBA::Boolean wipe(::CORBA::Long start, ::CORBA::Long frames);
    void jump(::CORBA::Long offset, ::CORBA::Boolean disablePreload);
    void jumpRelative(::CORBA::Long offset);
    void setJump(::CORBA::Long offset);
    void setTransition(::Quentin::Port::TransitionType type, ::CORBA::Long frames, ::CORBA::Boolean autoPlay);
    void setSpeed(::CORBA::Float newSpeed);
    ::CORBA::Long jogAudio(::CORBA::Long frames);
    void jogSubFrames(::CORBA::Long subFrameTicks);
    void setInputAudioPatch(const ::Quentin::AudioPatchInfoList& patches, ::CORBA::Boolean preview);
    void setOutputAudioPatch(::CORBA::Long startFrame, ::CORBA::Long endFrame, const ::Quentin::AudioPatchInfoList& patches);
    ::CORBA::Long extendSpace(::CORBA::Long poolID, ::CORBA::Long totalFrames);
    ::CORBA::Long forget(::CORBA::Long offset);
    void setFlags(::CORBA::Long track, ::CORBA::Long newFlags);
    void setCrop(::CORBA::Long track, ::CORBA::Long cropLeft, ::CORBA::Long cropTop, ::CORBA::Long cropWidth, ::CORBA::Long cropHeight);
    void setAspect(::CORBA::Long track, ::CORBA::Long width, ::CORBA::Long height);
    void setOriginator(const ::CORBA::WChar* originator);
    void setRecordTimecodes(const ::Quentin::RushTimecodeList& timecodes);
    RushIdent getRushRecording(::Quentin::FragmentType type, ::CORBA::Long track);
    void setOverlayClipTitle(const ::CORBA::WChar* clipname, ::Quentin::Port::OverlayTextColour colour);
    void setOverlayIndicator(const ::CORBA::WChar* indicator, ::CORBA::Boolean active);
    void setOverlayTallyID(::CORBA::Long id, ::CORBA::Boolean numeric);

    inline _objref_Port()  { _PR_setobj(0); }  // nil
    _objref_Port(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Port();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Port(const _objref_Port&);
    _objref_Port& operator = (const _objref_Port&);
    // not implemented

    friend class Port;
  };

  class _pof_Port : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Port() : _OMNI_NS(proxyObjectFactory)(Port::_PD_repoId) {}
    virtual ~_pof_Port();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Port :
    public virtual _impl_Properties
  {
  public:
    virtual ~_impl_Port();

    virtual void changeFlags(::CORBA::Long mask, ::CORBA::Long newFlags) = 0;
    virtual ::CORBA::Boolean setMode(::Quentin::Port::PortMode newMode) = 0;
    virtual void reset() = 0;
    virtual void resetTriggers() = 0;
    virtual void resetTracks() = 0;
    virtual void setTrackLimits(::CORBA::Long startFrame, ::CORBA::Long endFrame) = 0;
    virtual Port::GeneralPortStatus getStatus() = 0;
    virtual void reportStatus(::Quentin::PortListener_ptr listener, ::CORBA::Long interval, ::CORBA::Long noteMask) = 0;
    virtual ::CORBA::Boolean setTrigger(::CORBA::Long trigger, ::Quentin::Port::TriggerMode mode, ::CORBA::Long param) = 0;
    virtual ::CORBA::Boolean actionAtTrigger(::CORBA::Long trigger, ::Quentin::Port::TriggerAction action) = 0;
    virtual Port::TriggerState getTrigger(::CORBA::Long trigger) = 0;
    virtual Port::TriggerStates* getTriggers() = 0;
    virtual ServerFragments* getPortFragments(::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getPortTypeFragments(::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long fragType) = 0;
    virtual ServerFragments* getPortTrackFragments(::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long fragType, ::CORBA::Long trackNum) = 0;
    virtual void getThumbnailSize(::CORBA::Long mode, ::CORBA::Long& width, ::CORBA::Long& height) = 0;
    virtual void setThumbnailListener(::CORBA::Long mode, ::CORBA::Long chanNum, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener, ::CORBA::Long minInterval) = 0;
    virtual ::CORBA::Long requestThumbnails(::CORBA::Long mode, ::CORBA::Long chanNum, ::CORBA::Long offset, ::CORBA::Long stride, ::CORBA::Long count, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener) = 0;
    virtual void abortThumbnails(::CORBA::Long abortID) = 0;
    virtual WStrings* controllerNames() = 0;
    virtual EffectController_ptr getController(::CORBA::Long trackNum) = 0;
    virtual PortInfo* getPortInfo() = 0;
    virtual DirectoryViewer_ptr getDirViewer(::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName) = 0;
    virtual DirectoryViewer_ptr getPoolDirViewer(::CORBA::Long poolID, ::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName) = 0;
    virtual ConfigDescriptionList* getConfigurations(::CORBA::Long channel, ::Quentin::FragmentType type, ::CORBA::Boolean forPlay) = 0;
    virtual Longs* getDefaultConfigurations(::CORBA::Long channel) = 0;
    virtual Longs* getCurrentConfigurations(::CORBA::Long channel) = 0;
    virtual void configure(::CORBA::Long channel, const ::Quentin::Longs& configurations) = 0;
    virtual ::CORBA::Boolean assignChannel(::CORBA::Long chanNum, ::CORBA::Long flags) = 0;
    virtual void assignTransitionPort(::Quentin::Port_ptr transitionPort) = 0;
    virtual Port_ptr getTransitionPort() = 0;
    virtual Longs* getChannels() = 0;
    virtual void release() = 0;
    virtual void load(::CORBA::Long offset, const ::Quentin::ServerFragments& fragments) = 0;
    virtual void insertBlank(::CORBA::Long start, ::CORBA::Long frames) = 0;
    virtual ::CORBA::Boolean remove(::CORBA::Long start, ::CORBA::Long frames) = 0;
    virtual ::CORBA::Boolean wipe(::CORBA::Long start, ::CORBA::Long frames) = 0;
    virtual void jump(::CORBA::Long offset, ::CORBA::Boolean disablePreload) = 0;
    virtual void jumpRelative(::CORBA::Long offset) = 0;
    virtual void setJump(::CORBA::Long offset) = 0;
    virtual void setTransition(::Quentin::Port::TransitionType type, ::CORBA::Long frames, ::CORBA::Boolean autoPlay) = 0;
    virtual void setSpeed(::CORBA::Float newSpeed) = 0;
    virtual ::CORBA::Long jogAudio(::CORBA::Long frames) = 0;
    virtual void jogSubFrames(::CORBA::Long subFrameTicks) = 0;
    virtual void setInputAudioPatch(const ::Quentin::AudioPatchInfoList& patches, ::CORBA::Boolean preview) = 0;
    virtual void setOutputAudioPatch(::CORBA::Long startFrame, ::CORBA::Long endFrame, const ::Quentin::AudioPatchInfoList& patches) = 0;
    virtual ::CORBA::Long extendSpace(::CORBA::Long poolID, ::CORBA::Long totalFrames) = 0;
    virtual ::CORBA::Long forget(::CORBA::Long offset) = 0;
    virtual void setFlags(::CORBA::Long track, ::CORBA::Long newFlags) = 0;
    virtual void setCrop(::CORBA::Long track, ::CORBA::Long cropLeft, ::CORBA::Long cropTop, ::CORBA::Long cropWidth, ::CORBA::Long cropHeight) = 0;
    virtual void setAspect(::CORBA::Long track, ::CORBA::Long width, ::CORBA::Long height) = 0;
    virtual void setOriginator(const ::CORBA::WChar* originator) = 0;
    virtual void setRecordTimecodes(const ::Quentin::RushTimecodeList& timecodes) = 0;
    virtual RushIdent getRushRecording(::Quentin::FragmentType type, ::CORBA::Long track) = 0;
    virtual void setOverlayClipTitle(const ::CORBA::WChar* clipname, ::Quentin::Port::OverlayTextColour colour) = 0;
    virtual void setOverlayIndicator(const ::CORBA::WChar* indicator, ::CORBA::Boolean active) = 0;
    virtual void setOverlayTallyID(::CORBA::Long id, ::CORBA::Boolean numeric) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __Quentin_mServer__
#define __Quentin_mServer__

  class Server;
  class _objref_Server;
  class _impl_Server;
  
  typedef _objref_Server* Server_ptr;
  typedef Server_ptr ServerRef;

  class Server_Helper {
  public:
    typedef Server_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Server, Server_Helper> Server_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Server,Server_Helper > Server_out;

#endif

  // interface Server
  class Server {
  public:
    // Declarations for this interface type.
    typedef Server_ptr _ptr_type;
    typedef Server_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Server :
    public virtual _objref_Properties
  {
  public:
    ServerInfo* getServerInfo();
    Port_ptr getPort(const ::CORBA::WChar* ident, ::CORBA::Long number);
    WStrings* getPortNames();
    WStrings* getChanPorts();
    ::CORBA::LongLong getFreeProtons(::CORBA::Long poolIdent);
    Longs* getPools();
    Timecode getRefTime();
    ConfigDescriptionList* getConfigurations(::CORBA::Long channel, ::Quentin::FragmentType type, ::CORBA::Boolean forPlay);
    Longs* getDefaultConfigurations(::CORBA::Long channel);
    Longs* getCurrentConfigurations(::CORBA::Long channel);
    ServerCapabilities* getServerCapabilities();

    inline _objref_Server()  { _PR_setobj(0); }  // nil
    _objref_Server(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Server();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Server(const _objref_Server&);
    _objref_Server& operator = (const _objref_Server&);
    // not implemented

    friend class Server;
  };

  class _pof_Server : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Server() : _OMNI_NS(proxyObjectFactory)(Server::_PD_repoId) {}
    virtual ~_pof_Server();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Server :
    public virtual _impl_Properties
  {
  public:
    virtual ~_impl_Server();

    virtual ServerInfo* getServerInfo() = 0;
    virtual Port_ptr getPort(const ::CORBA::WChar* ident, ::CORBA::Long number) = 0;
    virtual WStrings* getPortNames() = 0;
    virtual WStrings* getChanPorts() = 0;
    virtual ::CORBA::LongLong getFreeProtons(::CORBA::Long poolIdent) = 0;
    virtual Longs* getPools() = 0;
    virtual Timecode getRefTime() = 0;
    virtual ConfigDescriptionList* getConfigurations(::CORBA::Long channel, ::Quentin::FragmentType type, ::CORBA::Boolean forPlay) = 0;
    virtual Longs* getDefaultConfigurations(::CORBA::Long channel) = 0;
    virtual Longs* getCurrentConfigurations(::CORBA::Long channel) = 0;
    virtual ServerCapabilities* getServerCapabilities() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __Quentin_mDirectoryViewer__
#define __Quentin_mDirectoryViewer__

  class DirectoryViewer;
  class _objref_DirectoryViewer;
  class _impl_DirectoryViewer;
  
  typedef _objref_DirectoryViewer* DirectoryViewer_ptr;
  typedef DirectoryViewer_ptr DirectoryViewerRef;

  class DirectoryViewer_Helper {
  public:
    typedef DirectoryViewer_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DirectoryViewer, DirectoryViewer_Helper> DirectoryViewer_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DirectoryViewer,DirectoryViewer_Helper > DirectoryViewer_out;

#endif

  // interface DirectoryViewer
  class DirectoryViewer {
  public:
    // Declarations for this interface type.
    typedef DirectoryViewer_ptr _ptr_type;
    typedef DirectoryViewer_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_DirectoryViewer :
    public virtual _objref_Properties
  {
  public:
    ColumnDescList* getColumnDescriptions();
    void setDatabase(::CORBA::Long databaseNum);
    ::CORBA::Long createClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags);
    ::CORBA::Long createPlacedClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority);
    Longs* findFragsOnPools(const ::Quentin::ServerFragments& frags, const ::Quentin::Longs& pools);
    Longs* findClipOnPools(::CORBA::Long clipID, const ::Quentin::Longs& pools);
    ServerFragments* getAllFragments(::CORBA::Long clipID);
    ServerFragments* getFragments(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getFragmentsWithMode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long playMode);
    ServerFragments* getTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType);
    ServerFragments* getSubTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum);
    ServerFragments* getSubTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum, ::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getSourceTimecode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish);
    WStrings* getClipData(::CORBA::Long clipID, const ::Quentin::WStrings& colsWanted);
    void updateClip(::CORBA::Long clipID, const ::Quentin::ClipPropertyList& newColumns);
    ::CORBA::Boolean deleteClip(::CORBA::Long clipID);
    ::CORBA::Long trimUnrecorded(::CORBA::Long clipID);
    ::CORBA::Long numberClip(::CORBA::Long clipID, ::CORBA::Long number, ::Quentin::ConflictMode confMode);
    ::CORBA::Long scanNumbers(::CORBA::Long poolID, ::CORBA::Long number, ::Quentin::FindMode mode);
    ::CORBA::Long cloneClip(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority);
    ::CORBA::Long cloneIfNeeded(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority, ::CORBA::Long expirySecs, ::CORBA::Boolean& copyCreated);
    void replaceContent(::CORBA::Long clipID, ::CORBA::Long contentType, const ::Quentin::ServerFragments& frags);
    ::CORBA::Long getNumberedClip(::CORBA::Long number);
    void setColumnSelection(const ::Quentin::WStrings& colsWanted);
    WStrings* getColumnSelection();
    ::CORBA::Long maxSearchHits(::CORBA::Long newMax);
    ::CORBA::Long search(const ::Quentin::ClipPropertyList& props, ::CORBA::Long max);
    WStrings* getSearchResults(::CORBA::Long numRows);
    ::CORBA::Long moveSearch(::CORBA::Long newPos);
    ::CORBA::Long getSearchPos();
    void closeSearch();
    Longs* getTaggedClips(const ::CORBA::WChar* tag, const ::CORBA::WChar* keys);
    void getThumbnailSize(::CORBA::Long mode, ::CORBA::Long& width, ::CORBA::Long& height);
    ::CORBA::Long requestThumbnails(::CORBA::Long mode, const ::Quentin::PositionData& fragment, ::CORBA::Long offset, ::CORBA::Long stride, ::CORBA::Long count, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener);
    void abortThumbnails(::CORBA::Long abortID);
    ::CORBA::Long getTicket();
    void freeTicket(::CORBA::Long ticket);
    ::CORBA::Long getFreeTickets();
    void release();
    WStrings* directQuery(const ::CORBA::WChar* command);
    ::CORBA::WChar* getServerTime();
    ::CORBA::Long queryFreed(::CORBA::Long poolID, const ::Quentin::Longs& clips);
    Longs* getPools(::CORBA::Long clipID);
    ::CORBA::LongLong getFreeProtons(::CORBA::Long poolIdent);

    inline _objref_DirectoryViewer()  { _PR_setobj(0); }  // nil
    _objref_DirectoryViewer(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DirectoryViewer();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DirectoryViewer(const _objref_DirectoryViewer&);
    _objref_DirectoryViewer& operator = (const _objref_DirectoryViewer&);
    // not implemented

    friend class DirectoryViewer;
  };

  class _pof_DirectoryViewer : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DirectoryViewer() : _OMNI_NS(proxyObjectFactory)(DirectoryViewer::_PD_repoId) {}
    virtual ~_pof_DirectoryViewer();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DirectoryViewer :
    public virtual _impl_Properties
  {
  public:
    virtual ~_impl_DirectoryViewer();

    virtual ColumnDescList* getColumnDescriptions() = 0;
    virtual void setDatabase(::CORBA::Long databaseNum) = 0;
    virtual ::CORBA::Long createClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags) = 0;
    virtual ::CORBA::Long createPlacedClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority) = 0;
    virtual Longs* findFragsOnPools(const ::Quentin::ServerFragments& frags, const ::Quentin::Longs& pools) = 0;
    virtual Longs* findClipOnPools(::CORBA::Long clipID, const ::Quentin::Longs& pools) = 0;
    virtual ServerFragments* getAllFragments(::CORBA::Long clipID) = 0;
    virtual ServerFragments* getFragments(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getFragmentsWithMode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long playMode) = 0;
    virtual ServerFragments* getTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType) = 0;
    virtual ServerFragments* getSubTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum) = 0;
    virtual ServerFragments* getSubTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getSourceTimecode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual WStrings* getClipData(::CORBA::Long clipID, const ::Quentin::WStrings& colsWanted) = 0;
    virtual void updateClip(::CORBA::Long clipID, const ::Quentin::ClipPropertyList& newColumns) = 0;
    virtual ::CORBA::Boolean deleteClip(::CORBA::Long clipID) = 0;
    virtual ::CORBA::Long trimUnrecorded(::CORBA::Long clipID) = 0;
    virtual ::CORBA::Long numberClip(::CORBA::Long clipID, ::CORBA::Long number, ::Quentin::ConflictMode confMode) = 0;
    virtual ::CORBA::Long scanNumbers(::CORBA::Long poolID, ::CORBA::Long number, ::Quentin::FindMode mode) = 0;
    virtual ::CORBA::Long cloneClip(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority) = 0;
    virtual ::CORBA::Long cloneIfNeeded(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority, ::CORBA::Long expirySecs, ::CORBA::Boolean& copyCreated) = 0;
    virtual void replaceContent(::CORBA::Long clipID, ::CORBA::Long contentType, const ::Quentin::ServerFragments& frags) = 0;
    virtual ::CORBA::Long getNumberedClip(::CORBA::Long number) = 0;
    virtual void setColumnSelection(const ::Quentin::WStrings& colsWanted) = 0;
    virtual WStrings* getColumnSelection() = 0;
    virtual ::CORBA::Long maxSearchHits(::CORBA::Long newMax) = 0;
    virtual ::CORBA::Long search(const ::Quentin::ClipPropertyList& props, ::CORBA::Long max) = 0;
    virtual WStrings* getSearchResults(::CORBA::Long numRows) = 0;
    virtual ::CORBA::Long moveSearch(::CORBA::Long newPos) = 0;
    virtual ::CORBA::Long getSearchPos() = 0;
    virtual void closeSearch() = 0;
    virtual Longs* getTaggedClips(const ::CORBA::WChar* tag, const ::CORBA::WChar* keys) = 0;
    virtual void getThumbnailSize(::CORBA::Long mode, ::CORBA::Long& width, ::CORBA::Long& height) = 0;
    virtual ::CORBA::Long requestThumbnails(::CORBA::Long mode, const ::Quentin::PositionData& fragment, ::CORBA::Long offset, ::CORBA::Long stride, ::CORBA::Long count, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener) = 0;
    virtual void abortThumbnails(::CORBA::Long abortID) = 0;
    virtual ::CORBA::Long getTicket() = 0;
    virtual void freeTicket(::CORBA::Long ticket) = 0;
    virtual ::CORBA::Long getFreeTickets() = 0;
    virtual void release() = 0;
    virtual WStrings* directQuery(const ::CORBA::WChar* command) = 0;
    virtual ::CORBA::WChar* getServerTime() = 0;
    virtual ::CORBA::Long queryFreed(::CORBA::Long poolID, const ::Quentin::Longs& clips) = 0;
    virtual Longs* getPools(::CORBA::Long clipID) = 0;
    virtual ::CORBA::LongLong getFreeProtons(::CORBA::Long poolIdent) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __Quentin_mZonePortal__
#define __Quentin_mZonePortal__

  class ZonePortal;
  class _objref_ZonePortal;
  class _impl_ZonePortal;
  
  typedef _objref_ZonePortal* ZonePortal_ptr;
  typedef ZonePortal_ptr ZonePortalRef;

  class ZonePortal_Helper {
  public:
    typedef ZonePortal_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ZonePortal, ZonePortal_Helper> ZonePortal_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ZonePortal,ZonePortal_Helper > ZonePortal_out;

#endif

  // interface ZonePortal
  class ZonePortal {
  public:
    // Declarations for this interface type.
    typedef ZonePortal_ptr _ptr_type;
    typedef ZonePortal_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    static _core_attr const ::CORBA::WChar * idlVersion;

    static _core_attr const ::CORBA::Long copyNotDone _init_in_cldecl_( = 1073741824 );

    static _core_attr const ::CORBA::Long copyHasTicket _init_in_cldecl_( = 536870912 );

    static _core_attr const ::CORBA::Long copySourceDown _init_in_cldecl_( = 268435456 );

    static _core_attr const ::CORBA::Long copyDestDown _init_in_cldecl_( = 134217728 );

    static _core_attr const ::CORBA::Long copyFailed _init_in_cldecl_( = 67108864 );

    static _core_attr const ::CORBA::Long rushRecording _init_in_cldecl_( = 1073741824 );

  
  };

  class _objref_ZonePortal :
    public virtual _objref_Properties
  {
  public:
    ::CORBA::Long majorIDLVersion();
    Longs* getServers(::CORBA::Boolean negateIfDown);
    Server_ptr getServer(::CORBA::Long serverID);
    Longs* getPools();
    ::CORBA::LongLong getPoolSpace(::CORBA::Long mode, ::CORBA::Long poolID);
    Server_ptr getPoolServer(::CORBA::Long poolID);
    ::CORBA::LongLong getServerSpace(::CORBA::Long mode, ::CORBA::Long serverID);
    PoolInfo* getPoolInfo(::CORBA::Long poolID);
    DirectoryViewer_ptr getDirViewer(::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName);
    DirectoryViewer_ptr getPoolDirViewer(::CORBA::Long poolID, ::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName);
    ::CORBA::Boolean addStateChangeListener(::Quentin::StateChangeListener_ptr listener, ::CORBA::Long flags);
    ::CORBA::Boolean addNamedStateChangeListener(const ::CORBA::WChar* listenerName, ::Quentin::StateChangeListener_ptr listener, ::CORBA::Long flags, ::CORBA::Long interval);
    ::CORBA::Boolean removeStateChangeListener(::Quentin::StateChangeListener_ptr listener);
    StateChangeList* getStateChanges(::CORBA::Long changeNum);
    CopyProgress getCopyRemaining(::CORBA::Long clipID);
    CopyProgressList* getCopiesRemaining();
    CopyMapList* getCopyMap(::CORBA::Long clipID, ::Quentin::FragmentType type, ::CORBA::Long track);
    ::CORBA::Boolean deleteCopy(::CORBA::Long clipID);
    ::CORBA::Boolean ticketCopy(::CORBA::Long clipID, ::CORBA::Long ticket);
    ::CORBA::Boolean tryToTicketCopy(::CORBA::Long clipID);
    void unticketCopy(::CORBA::Long clipID);
    void addTag(const ::Quentin::RushTag& tagToAdd);
    void removeTag(const ::Quentin::RushTag& tagToRemove);
    RushTagList* getTags(const ::Quentin::RushIdent& rushID, const ::Quentin::WStrings& tagsWanted, ::CORBA::Long start, ::CORBA::Long finish);
    RushTimecodeList* getTimecodes(const ::Quentin::RushIdent& rushID, ::CORBA::Long start, ::CORBA::Long finish);
    void refresh(::CORBA::Long mode, ::CORBA::Long param);
    ColumnDescList* getColumnDescriptions();
    ::CORBA::Long createClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags);
    ::CORBA::Long createPlacedClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority);
    Longs* findFragsOnPools(const ::Quentin::ServerFragments& frags, const ::Quentin::Longs& pools);
    Longs* findClipOnPools(::CORBA::Long clipID, const ::Quentin::Longs& pools);
    ServerFragments* getAllFragments(::CORBA::Long clipID);
    ServerFragments* getFragments(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getFragmentsWithMode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long playMode);
    ServerFragments* getTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType);
    ServerFragments* getSubTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum);
    ServerFragments* getSubTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum, ::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getSourceTimecode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish);
    ServerFragments* getRefTimecode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish);
    WStrings* getClipData(::CORBA::Long clipID, const ::Quentin::WStrings& colsWanted);
    void updateClip(::CORBA::Long clipID, const ::Quentin::ClipPropertyList& newColumns);
    void setClipProtection(::CORBA::Long clipID, const ::CORBA::WChar* userID, ::Quentin::ProtectMode mode);
    ::CORBA::Boolean deleteClip(::CORBA::Long clipID);
    ::CORBA::Long trimUnrecorded(::CORBA::Long clipID);
    ::CORBA::Long numberClip(::CORBA::Long clipID, ::CORBA::Long number, ::Quentin::ConflictMode confMode);
    ::CORBA::Long scanNumbers(::CORBA::Long poolID, ::CORBA::Long number, ::Quentin::FindMode mode);
    ::CORBA::Long cloneClip(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority);
    ::CORBA::Long cloneClipInterZone(::CORBA::Long zoneID, ::CORBA::Long clipID, ::CORBA::Long poolID, ::CORBA::Long priority);
    ::CORBA::Long cloneClipInterZoneWithoutHistory(::CORBA::Long zoneID, ::CORBA::Long clipID, ::CORBA::Long poolID, ::CORBA::Long priority);
    ::CORBA::Long cloneIfNeeded(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority, ::CORBA::Long expirySecs, ::CORBA::Boolean& copyCreated);
    void replaceContent(::CORBA::Long clipID, ::CORBA::Long contentType, const ::Quentin::ServerFragments& frags);
    FullClipIDList* createPlaceholder(const ::Quentin::ClipPropertyList& props, const ::Quentin::Longs& pools);
    FullClipIDList* clonePlaceholder(::CORBA::Long clipID, const ::Quentin::Longs& pools);
    FullClipIDList* createExtPlaceholder(const ::Quentin::ClipPropertyList& props, const ::Quentin::Longs& pools, const ::Quentin::WStrings& extData);
    Longs* getPlaceholderPools(::CORBA::Long clipID);
    PlaceholderDataList* getPlaceholderData(::CORBA::Long clipID);
    FullClipIDList* fillPlaceholder(::CORBA::Long clipID, const ::Quentin::ServerFragments& frags, const ::Quentin::ClipPropertyList& props, ::CORBA::Long priority);
    void fillSinglePlaceholder(const ::Quentin::PlaceholderData& data, const ::Quentin::ServerFragments& frags, const ::Quentin::ClipPropertyList& props, ::CORBA::Long priority);
    ::CORBA::Long rushHighWater(const ::Quentin::RushIdent& rushID);
    ::CORBA::Long createDeltaFromClips(::CORBA::Long originalClipID, ::CORBA::Long laterClipID, const ::Quentin::ClipPropertyList& props);
    ::CORBA::Long createDeltaFromFragments(const ::Quentin::ServerFragments& originalFragments, const ::Quentin::ServerFragments& laterFragments, const ::Quentin::ClipPropertyList& props);
    ::CORBA::Long getPoolNumberedClip(::CORBA::Long number, ::CORBA::Long pool);
    WStrings* searchClips(const ::Quentin::ClipPropertyList& props, const ::Quentin::WStrings& columns, ::CORBA::Long max);
    ::CORBA::Long countClips(const ::Quentin::ClipPropertyList& props);
    WStrings* searchClipsWithOffset(const ::Quentin::ClipPropertyList& props, const ::Quentin::WStrings& columns, ::CORBA::Long offset, ::CORBA::Long max);
    WStrings* orderedSearchClips(const ::Quentin::ClipPropertyList& props, const ::Quentin::WStrings& columns, const ::Quentin::SortOrderList& order, ::CORBA::Long offset, ::CORBA::Long max);
    Longs* getTaggedClips(const ::CORBA::WChar* tag, const ::CORBA::WChar* keys);
    FormatInfo* getFormatInfo(::Quentin::FormatCode format);
    void getThumbnailSize(::CORBA::Long mode, ::CORBA::Long& width, ::CORBA::Long& height);
    ::CORBA::Long requestThumbnails(::CORBA::Long mode, const ::Quentin::PositionData& fragment, ::CORBA::Long offset, ::CORBA::Long stride, ::CORBA::Long count, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener);
    void abortThumbnails(::CORBA::Long abortID);
    ::CORBA::Long getTicket();
    void freeTicket(::CORBA::Long ticket);
    ::CORBA::Long getFreeTickets();
    WStrings* directQuery(const ::CORBA::WChar* command);
    void unregisterAll(::CORBA::Long database, ::CORBA::Long poolID);
    ::CORBA::WChar* getServerTime();
    ::CORBA::WChar* getSequence(const ::CORBA::WChar* prefix);
    WStrings* getAreaNames(::CORBA::Boolean search, const ::CORBA::WChar* propWanted);
    ClipPropertyList* getAreaPropertyList(const ::CORBA::WChar* areaName, ::CORBA::Boolean search);
    void setAreaProperties(const char* areaName, ::CORBA::Boolean search, const ::Quentin::ClipPropertyList& properties);
    ::CORBA::Long queryFreed(::CORBA::Long poolID, const ::Quentin::Longs& clips);
    ::CORBA::LongLong getFreeProtons(::CORBA::Long poolIdent);
    ::CORBA::Long getFreeFrames(::CORBA::Long poolIdent, const ::Quentin::FormatCodes& formats);
    ::CORBA::Long getZoneNumber();
    Longs* getZones(::CORBA::Boolean upOnly);
    ZonePortal_ptr getZonePortal(::CORBA::Long zoneID);
    ::CORBA::WChar* getZoneName(::CORBA::Long zoneID);
    ::CORBA::Boolean zoneIsRemote(::CORBA::Long zoneID);
    ::CORBA::Long maxAAFRecord();
    void putAAF(::CORBA::Long clipID, ::CORBA::Long record, const ::Quentin::RawData& data);
    ::CORBA::Long aafRecordLength(::CORBA::Long clipId);
    void getAAF(::CORBA::Long clipID, ::CORBA::Long record, ::Quentin::RawData_out data);
    WStrings* getLoggingRoles();
    WStrings* getLoggingRoleNames(const ::CORBA::WChar* role);
    ::CORBA::Long lastAAFRecord(::CORBA::Long clipID);

    inline _objref_ZonePortal()  { _PR_setobj(0); }  // nil
    _objref_ZonePortal(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ZonePortal();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ZonePortal(const _objref_ZonePortal&);
    _objref_ZonePortal& operator = (const _objref_ZonePortal&);
    // not implemented

    friend class ZonePortal;
  };

  class _pof_ZonePortal : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ZonePortal() : _OMNI_NS(proxyObjectFactory)(ZonePortal::_PD_repoId) {}
    virtual ~_pof_ZonePortal();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ZonePortal :
    public virtual _impl_Properties
  {
  public:
    virtual ~_impl_ZonePortal();

    virtual ::CORBA::Long majorIDLVersion() = 0;
    virtual Longs* getServers(::CORBA::Boolean negateIfDown) = 0;
    virtual Server_ptr getServer(::CORBA::Long serverID) = 0;
    virtual Longs* getPools() = 0;
    virtual ::CORBA::LongLong getPoolSpace(::CORBA::Long mode, ::CORBA::Long poolID) = 0;
    virtual Server_ptr getPoolServer(::CORBA::Long poolID) = 0;
    virtual ::CORBA::LongLong getServerSpace(::CORBA::Long mode, ::CORBA::Long serverID) = 0;
    virtual PoolInfo* getPoolInfo(::CORBA::Long poolID) = 0;
    virtual DirectoryViewer_ptr getDirViewer(::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName) = 0;
    virtual DirectoryViewer_ptr getPoolDirViewer(::CORBA::Long poolID, ::CORBA::Long timeoutSecs, const ::CORBA::WChar* viewerName) = 0;
    virtual ::CORBA::Boolean addStateChangeListener(::Quentin::StateChangeListener_ptr listener, ::CORBA::Long flags) = 0;
    virtual ::CORBA::Boolean addNamedStateChangeListener(const ::CORBA::WChar* listenerName, ::Quentin::StateChangeListener_ptr listener, ::CORBA::Long flags, ::CORBA::Long interval) = 0;
    virtual ::CORBA::Boolean removeStateChangeListener(::Quentin::StateChangeListener_ptr listener) = 0;
    virtual StateChangeList* getStateChanges(::CORBA::Long changeNum) = 0;
    virtual CopyProgress getCopyRemaining(::CORBA::Long clipID) = 0;
    virtual CopyProgressList* getCopiesRemaining() = 0;
    virtual CopyMapList* getCopyMap(::CORBA::Long clipID, ::Quentin::FragmentType type, ::CORBA::Long track) = 0;
    virtual ::CORBA::Boolean deleteCopy(::CORBA::Long clipID) = 0;
    virtual ::CORBA::Boolean ticketCopy(::CORBA::Long clipID, ::CORBA::Long ticket) = 0;
    virtual ::CORBA::Boolean tryToTicketCopy(::CORBA::Long clipID) = 0;
    virtual void unticketCopy(::CORBA::Long clipID) = 0;
    virtual void addTag(const ::Quentin::RushTag& tagToAdd) = 0;
    virtual void removeTag(const ::Quentin::RushTag& tagToRemove) = 0;
    virtual RushTagList* getTags(const ::Quentin::RushIdent& rushID, const ::Quentin::WStrings& tagsWanted, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual RushTimecodeList* getTimecodes(const ::Quentin::RushIdent& rushID, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual void refresh(::CORBA::Long mode, ::CORBA::Long param) = 0;
    virtual ColumnDescList* getColumnDescriptions() = 0;
    virtual ::CORBA::Long createClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags) = 0;
    virtual ::CORBA::Long createPlacedClip(const ::Quentin::ClipPropertyList& props, const ::Quentin::ServerFragments& frags, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority) = 0;
    virtual Longs* findFragsOnPools(const ::Quentin::ServerFragments& frags, const ::Quentin::Longs& pools) = 0;
    virtual Longs* findClipOnPools(::CORBA::Long clipID, const ::Quentin::Longs& pools) = 0;
    virtual ServerFragments* getAllFragments(::CORBA::Long clipID) = 0;
    virtual ServerFragments* getFragments(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getFragmentsWithMode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish, ::CORBA::Long playMode) = 0;
    virtual ServerFragments* getTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType) = 0;
    virtual ServerFragments* getSubTypeFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum) = 0;
    virtual ServerFragments* getSubTrackFragments(::CORBA::Long clipID, ::CORBA::Long trackType, ::CORBA::Long trackNum, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getSourceTimecode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual ServerFragments* getRefTimecode(::CORBA::Long clipID, ::CORBA::Long start, ::CORBA::Long finish) = 0;
    virtual WStrings* getClipData(::CORBA::Long clipID, const ::Quentin::WStrings& colsWanted) = 0;
    virtual void updateClip(::CORBA::Long clipID, const ::Quentin::ClipPropertyList& newColumns) = 0;
    virtual void setClipProtection(::CORBA::Long clipID, const ::CORBA::WChar* userID, ::Quentin::ProtectMode mode) = 0;
    virtual ::CORBA::Boolean deleteClip(::CORBA::Long clipID) = 0;
    virtual ::CORBA::Long trimUnrecorded(::CORBA::Long clipID) = 0;
    virtual ::CORBA::Long numberClip(::CORBA::Long clipID, ::CORBA::Long number, ::Quentin::ConflictMode confMode) = 0;
    virtual ::CORBA::Long scanNumbers(::CORBA::Long poolID, ::CORBA::Long number, ::Quentin::FindMode mode) = 0;
    virtual ::CORBA::Long cloneClip(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority) = 0;
    virtual ::CORBA::Long cloneClipInterZone(::CORBA::Long zoneID, ::CORBA::Long clipID, ::CORBA::Long poolID, ::CORBA::Long priority) = 0;
    virtual ::CORBA::Long cloneClipInterZoneWithoutHistory(::CORBA::Long zoneID, ::CORBA::Long clipID, ::CORBA::Long poolID, ::CORBA::Long priority) = 0;
    virtual ::CORBA::Long cloneIfNeeded(::CORBA::Long clipID, ::CORBA::Long poolIdent, ::CORBA::Long ticket, ::CORBA::Long priority, ::CORBA::Long expirySecs, ::CORBA::Boolean& copyCreated) = 0;
    virtual void replaceContent(::CORBA::Long clipID, ::CORBA::Long contentType, const ::Quentin::ServerFragments& frags) = 0;
    virtual FullClipIDList* createPlaceholder(const ::Quentin::ClipPropertyList& props, const ::Quentin::Longs& pools) = 0;
    virtual FullClipIDList* clonePlaceholder(::CORBA::Long clipID, const ::Quentin::Longs& pools) = 0;
    virtual FullClipIDList* createExtPlaceholder(const ::Quentin::ClipPropertyList& props, const ::Quentin::Longs& pools, const ::Quentin::WStrings& extData) = 0;
    virtual Longs* getPlaceholderPools(::CORBA::Long clipID) = 0;
    virtual PlaceholderDataList* getPlaceholderData(::CORBA::Long clipID) = 0;
    virtual FullClipIDList* fillPlaceholder(::CORBA::Long clipID, const ::Quentin::ServerFragments& frags, const ::Quentin::ClipPropertyList& props, ::CORBA::Long priority) = 0;
    virtual void fillSinglePlaceholder(const ::Quentin::PlaceholderData& data, const ::Quentin::ServerFragments& frags, const ::Quentin::ClipPropertyList& props, ::CORBA::Long priority) = 0;
    virtual ::CORBA::Long rushHighWater(const ::Quentin::RushIdent& rushID) = 0;
    virtual ::CORBA::Long createDeltaFromClips(::CORBA::Long originalClipID, ::CORBA::Long laterClipID, const ::Quentin::ClipPropertyList& props) = 0;
    virtual ::CORBA::Long createDeltaFromFragments(const ::Quentin::ServerFragments& originalFragments, const ::Quentin::ServerFragments& laterFragments, const ::Quentin::ClipPropertyList& props) = 0;
    virtual ::CORBA::Long getPoolNumberedClip(::CORBA::Long number, ::CORBA::Long pool) = 0;
    virtual WStrings* searchClips(const ::Quentin::ClipPropertyList& props, const ::Quentin::WStrings& columns, ::CORBA::Long max) = 0;
    virtual ::CORBA::Long countClips(const ::Quentin::ClipPropertyList& props) = 0;
    virtual WStrings* searchClipsWithOffset(const ::Quentin::ClipPropertyList& props, const ::Quentin::WStrings& columns, ::CORBA::Long offset, ::CORBA::Long max) = 0;
    virtual WStrings* orderedSearchClips(const ::Quentin::ClipPropertyList& props, const ::Quentin::WStrings& columns, const ::Quentin::SortOrderList& order, ::CORBA::Long offset, ::CORBA::Long max) = 0;
    virtual Longs* getTaggedClips(const ::CORBA::WChar* tag, const ::CORBA::WChar* keys) = 0;
    virtual FormatInfo* getFormatInfo(::Quentin::FormatCode format) = 0;
    virtual void getThumbnailSize(::CORBA::Long mode, ::CORBA::Long& width, ::CORBA::Long& height) = 0;
    virtual ::CORBA::Long requestThumbnails(::CORBA::Long mode, const ::Quentin::PositionData& fragment, ::CORBA::Long offset, ::CORBA::Long stride, ::CORBA::Long count, ::CORBA::Long ident, ::Quentin::ThumbnailListener_ptr listener) = 0;
    virtual void abortThumbnails(::CORBA::Long abortID) = 0;
    virtual ::CORBA::Long getTicket() = 0;
    virtual void freeTicket(::CORBA::Long ticket) = 0;
    virtual ::CORBA::Long getFreeTickets() = 0;
    virtual WStrings* directQuery(const ::CORBA::WChar* command) = 0;
    virtual void unregisterAll(::CORBA::Long database, ::CORBA::Long poolID) = 0;
    virtual ::CORBA::WChar* getServerTime() = 0;
    virtual ::CORBA::WChar* getSequence(const ::CORBA::WChar* prefix) = 0;
    virtual WStrings* getAreaNames(::CORBA::Boolean search, const ::CORBA::WChar* propWanted) = 0;
    virtual ClipPropertyList* getAreaPropertyList(const ::CORBA::WChar* areaName, ::CORBA::Boolean search) = 0;
    virtual void setAreaProperties(const char* areaName, ::CORBA::Boolean search, const ::Quentin::ClipPropertyList& properties) = 0;
    virtual ::CORBA::Long queryFreed(::CORBA::Long poolID, const ::Quentin::Longs& clips) = 0;
    virtual ::CORBA::LongLong getFreeProtons(::CORBA::Long poolIdent) = 0;
    virtual ::CORBA::Long getFreeFrames(::CORBA::Long poolIdent, const ::Quentin::FormatCodes& formats) = 0;
    virtual ::CORBA::Long getZoneNumber() = 0;
    virtual Longs* getZones(::CORBA::Boolean upOnly) = 0;
    virtual ZonePortal_ptr getZonePortal(::CORBA::Long zoneID) = 0;
    virtual ::CORBA::WChar* getZoneName(::CORBA::Long zoneID) = 0;
    virtual ::CORBA::Boolean zoneIsRemote(::CORBA::Long zoneID) = 0;
    virtual ::CORBA::Long maxAAFRecord() = 0;
    virtual void putAAF(::CORBA::Long clipID, ::CORBA::Long record, const ::Quentin::RawData& data) = 0;
    virtual ::CORBA::Long aafRecordLength(::CORBA::Long clipId) = 0;
    virtual void getAAF(::CORBA::Long clipID, ::CORBA::Long record, ::Quentin::RawData_out data) = 0;
    virtual WStrings* getLoggingRoles() = 0;
    virtual WStrings* getLoggingRoleNames(const ::CORBA::WChar* role) = 0;
    virtual ::CORBA::Long lastAAFRecord(::CORBA::Long clipID) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_Quentin
_CORBA_MODULE_BEG

  class Properties :
    public virtual Quentin::_impl_Properties,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Properties();

    inline ::Quentin::Properties_ptr _this() {
      return (::Quentin::Properties_ptr) _do_this(::Quentin::Properties::_PD_repoId);
    }
  };

  class EffectController :
    public virtual Quentin::_impl_EffectController,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~EffectController();

    inline ::Quentin::EffectController_ptr _this() {
      return (::Quentin::EffectController_ptr) _do_this(::Quentin::EffectController::_PD_repoId);
    }
  };

  class ThumbnailListener :
    public virtual Quentin::_impl_ThumbnailListener,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ThumbnailListener();

    inline ::Quentin::ThumbnailListener_ptr _this() {
      return (::Quentin::ThumbnailListener_ptr) _do_this(::Quentin::ThumbnailListener::_PD_repoId);
    }
  };

  class PortListener :
    public virtual Quentin::_impl_PortListener,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PortListener();

    inline ::Quentin::PortListener_ptr _this() {
      return (::Quentin::PortListener_ptr) _do_this(::Quentin::PortListener::_PD_repoId);
    }
  };

  class StateChangeListener :
    public virtual Quentin::_impl_StateChangeListener,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~StateChangeListener();

    inline ::Quentin::StateChangeListener_ptr _this() {
      return (::Quentin::StateChangeListener_ptr) _do_this(::Quentin::StateChangeListener::_PD_repoId);
    }
  };

  class Port :
    public virtual Quentin::_impl_Port,
    public virtual Properties
  {
  public:
    virtual ~Port();

    inline ::Quentin::Port_ptr _this() {
      return (::Quentin::Port_ptr) _do_this(::Quentin::Port::_PD_repoId);
    }
  };

  class Server :
    public virtual Quentin::_impl_Server,
    public virtual Properties
  {
  public:
    virtual ~Server();

    inline ::Quentin::Server_ptr _this() {
      return (::Quentin::Server_ptr) _do_this(::Quentin::Server::_PD_repoId);
    }
  };

  class DirectoryViewer :
    public virtual Quentin::_impl_DirectoryViewer,
    public virtual Properties
  {
  public:
    virtual ~DirectoryViewer();

    inline ::Quentin::DirectoryViewer_ptr _this() {
      return (::Quentin::DirectoryViewer_ptr) _do_this(::Quentin::DirectoryViewer::_PD_repoId);
    }
  };

  class ZonePortal :
    public virtual Quentin::_impl_ZonePortal,
    public virtual Properties
  {
  public:
    virtual ~ZonePortal();

    inline ::Quentin::ZonePortal_ptr _this() {
      return (::Quentin::ZonePortal_ptr) _do_this(::Quentin::ZonePortal::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_Quentin
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(Quentin::ConflictMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::ConflictMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::fail) {
    _e = (Quentin::ConflictMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::FindMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::FindMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::findBackwards) {
    _e = (Quentin::FindMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::SortDirection _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::SortDirection& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::descending) {
    _e = (Quentin::SortDirection) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::ProtectMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::ProtectMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::protectDelete) {
    _e = (Quentin::ProtectMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::StateChangeType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::StateChangeType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::aafUpdated) {
    _e = (Quentin::StateChangeType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::FragmentType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::FragmentType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::numFragmentTypes) {
    _e = (Quentin::FragmentType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::ChannelType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::ChannelType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::simplexPlayback) {
    _e = (Quentin::ChannelType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::BadIdentReason _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::BadIdentReason& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::operationNotSupported) {
    _e = (Quentin::BadIdentReason) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::ThumbnailListener::NoThumbnailReason _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::ThumbnailListener::NoThumbnailReason& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::ThumbnailListener::hardwareError) {
    _e = (Quentin::ThumbnailListener::NoThumbnailReason) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::Port::TriggerMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::Port::TriggerMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::Port::trNumModes) {
    _e = (Quentin::Port::TriggerMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::Port::TriggerAction _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::Port::TriggerAction& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::Port::trNumActions) {
    _e = (Quentin::Port::TriggerAction) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::Port::PortMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::Port::PortMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::Port::playing) {
    _e = (Quentin::Port::PortMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::Port::TransitionType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::Port::TransitionType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::Port::crossFadeWithAudioMix) {
    _e = (Quentin::Port::TransitionType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(Quentin::Port::OverlayTextColour _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (Quentin::Port::OverlayTextColour& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= Quentin::Port::olColourMagenta) {
    _e = (Quentin::Port::OverlayTextColour) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}



inline void
Quentin::Properties::_marshalObjRef(::Quentin::Properties_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::EffectController::_marshalObjRef(::Quentin::EffectController_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::ThumbnailListener::_marshalObjRef(::Quentin::ThumbnailListener_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::PortListener::_marshalObjRef(::Quentin::PortListener_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::StateChangeListener::_marshalObjRef(::Quentin::StateChangeListener_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::Port::_marshalObjRef(::Quentin::Port_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::Server::_marshalObjRef(::Quentin::Server_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::DirectoryViewer::_marshalObjRef(::Quentin::DirectoryViewer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
Quentin::ZonePortal::_marshalObjRef(::Quentin::ZonePortal_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_Quentin
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_Quentin
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_Quentin
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_Quentin
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_Quentin
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_Quentin
#endif

#endif  // __Quentin_hh__

